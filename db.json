{
  "questions": [
    {
      "id": "1",
      "title": "Які принципи програмування ви знаєте та яких з них ви намагаєтесь дотримуватись найчастіше?",
      "body": "Принципи програмування включають: KISS (Keep It Simple, Stupid), DRY (Don't Repeat Yourself), YAGNI (You Aren't Gonna Need It), принцип єдиної відповідальності, інкапсуляцію, наслідування, поліморфізм. Найчастіше намагаюся дотримуватися принципів KISS, DRY та інкапсуляції.",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "2",
      "title": "Що таке парадигма ООП? Які основні складові парадигми?",
      "body": "Об'єктно-орієнтоване програмування (ООП) — це парадигма програмування, в якій основними елементами є об'єкти — сутності, що поєднують дані та методи для роботи з ними. Основні складові ООП: абстракція, інкапсуляція, наслідування та поліморфізм.",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "3",
      "title": "Навіщо потрібна інкапсуляція? Що може статися і не статися, якщо всі методи матимуть модифікатор доступу public?",
      "body": "Інкапсуляція забезпечує приховування внутрішньої реалізації об'єкта, дозволяючи взаємодіяти з ним лише через визначений інтерфейс. Якщо всі методи матимуть модифікатор доступу public, це може призвести до небажаного доступу та модифікації внутрішнього стану об'єкта, що ускладнить підтримку та може призвести до помилок.",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "4",
      "title": "Що таке наслідування? Назвіть приклад(и) поганого наслідування (таке наслідування, яке не варто було б реалізовувати).",
      "body": "Наслідування — це механізм, який дозволяє одному класу (дочірньому) успадковувати властивості та методи іншого класу (батьківського). Поганим прикладом наслідування є ситуація, коли дочірній клас не є спеціалізацією батьківського, наприклад, якщо клас 'Квадрат' наслідується від класу 'Прямокутник', оскільки квадрат є окремим випадком прямокутника, але не всі прямокутники є квадратами.",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "5",
      "title": "Що таке поліморфізм? Наведіть приклад використання поліморфізму.",
      "body": "Поліморфізм — це здатність об'єктів різних класів реагувати на однакові повідомлення (виклики методів) по-різному. Приклад: метод 'draw()' може бути реалізований у класах 'Коло', 'Квадрат' та 'Трикутник', і виклик цього методу для об'єкта будь-якого з цих класів виконає відповідну операцію малювання.",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "6",
      "title": "Що таке патерн/шаблон проєктування? Які шаблони знаєте?",
      "body": "Патерн проєктування — це повторюване рішення загальної проблеми в розробці програмного забезпечення. Відомі шаблони: Singleton, Factory Method, Observer, Strategy, Decorator, Adapter, Facade.",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "7",
      "title": "Що таке клієнт і сервер? Яка механіка їхньої взаємодії?",
      "body": "Клієнт — це пристрій або програма, яка надсилає запити для отримання ресурсів або послуг. Сервер — це пристрій або програма, яка обробляє ці запити та надає ресурси або послуги. Взаємодія відбувається за моделлю 'запит-відповідь': клієнт надсилає запит, сервер обробляє його та повертає відповідь.",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "8",
      "title": "Опишіть шлях, який проходить запит після того, як у браузер ввести URL будь-якого ресурсу?",
      "body": "Після введення URL у браузері відбувається: 1) Перетворення доменного імені в IP-адресу через DNS-запит. 2) Встановлення TCP-з'єднання з сервером. 3) Надсилання HTTP-запиту до сервера. 4) Обробка запиту сервером та повернення HTTP-відповіді. 5) Отримання та відображення браузером вмісту сторінки.",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "9",
      "title": "Що таке протокол HTTP? Яка різниця між HTTP та HTTPS?",
      "body": "HTTP (HyperText Transfer Protocol) — це протокол передачі гіпертексту, який використовується для обміну даними між клієнтом і сервером у вебсередовищі. HTTPS (HTTP Secure) — це розширення HTTP, яке використовує шифрування (SSL/TTLS) для забезпечення безпеки передачі даних. Різниця між ними полягає в тому, що HTTPS забезпечує конфіденційність та цілісність даних, тоді як HTTP передає дані у відкритому вигляді.",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "10",
      "title": "Що таке API? Чи може вебзастосунок використовувати більше, ніж один API?",
      "body": "API (Application Programming Interface) — це набір визначень та протоколів для взаємодії між різними програмними компонентами. Вебзастосунок може використовувати більше ніж один API для інтеграції з різними сервісами або для розширення функціональності.",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "11",
      "title": "Що таке REST API? Які дії найчастіше виконуються над ресурсами?",
      "body": "REST API (Representational State Transfer Application Programming Interface) — це стиль архітектури програмного інтерфейсу, який використовує HTTP-протокол для взаємодії з ресурсами. Найчастіше над ресурсами виконуються такі дії: створення (POST), читання (GET), оновлення (PUT/PATCH) та видалення (DELETE).",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "12",
      "title": "Що таке сесія? Що таке cookies? Яка різниця між ними?",
      "body": "Сесія — це механізм збереження даних про користувача на сервері протягом його взаємодії з веб-додатком. Вона дозволяє зберігати інформацію про стан користувача між запитами. Cookies — це невеликі текстові файли, які зберігаються на пристрої користувача та використовуються для збереження інформації, такої як налаштування або ідентифікатори сесій. Основна різниця між ними полягає в місці збереження даних: сесії зберігаються на сервері, тоді як cookies — на стороні клієнта.",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "13",
      "title": "Які вебвразливості знаєте? Як від них захиститися? Які є інструменти, щоб автоматично контролювати захист від вебвразливостей?",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "14",
      "title": "Якими критеріями користуєтесь для вибору бібліотеки?",
      "body": "При виборі бібліотеки враховую такі критерії: 1. **Популярність та активність спільноти**: велика спільнота забезпечує швидке виявлення та виправлення помилок. 2. **Документація**: наявність детальної та зрозумілої документації спрощує інтеграцію та використання. 3. **Сумісність**: відповідність бібліотеки з поточними технологіями та версіями. 4. **Ліцензія**: відповідність ліцензії умовам використання у проєкті. 5. **Продуктивність**: оцінка впливу на швидкодію та ресурси системи.",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "15",
      "title": "Що таке рефакторинг? Які повинні бути умови для виконання рефакторингу?",
      "body": "Рефакторинг — це процес поліпшення внутрішньої структури коду без зміни його зовнішньої поведінки. Мета — підвищення читабельності, спрощення підтримки та розширення функціональності. Умови для виконання рефакторингу: 1. **Наявність тестів**: забезпечення покриття коду тестами для перевірки правильності роботи після змін. 2. **Розуміння поточного коду**: детальний аналіз та розуміння існуючої реалізації. 3. **Часові ресурси**: наявність достатнього часу для внесення та перевірки змін.",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "16",
      "title": "Чи знаєте ви сімейство UNIX-подібних операційних систем (Linux, MacOS)? Назвіть команди, які найчастіше використовуєте в терміналі.",
      "body": "Так, знайомий із UNIX-подібними операційними системами, такими як Linux та MacOS. Найчастіше використовую такі команди в терміналі: 1. **ls**: перелік файлів та директорій. 2. **cd**: зміна поточної директорії. 3. **pwd**: відображення шляху до поточної директорії. 4. **cp**: копіювання файлів або директорій. 5. **mv**: переміщення або перейменування файлів/директорій. 6. **rm**: видалення файлів або директорій. 7. **grep**: пошук тексту в файлах. 8. **chmod**: зміна прав доступу до файлів/директорій. 9. **ssh**: підключення до віддалених серверів.",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "17",
      "title": "Що таке аутентифікація?",
      "body": "Аутентифікація — це процес перевірки особи користувача або системи, зазвичай шляхом перевірки введених ними даних (наприклад, логін та пароль) з наявними у системі. Мета — підтвердити, що користувач є тим, за кого себе видає.",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "18",
      "title": "Що таке авторизація?",
      "body": "Авторизація — це процес визначення прав та привілеїв користувача після його аутентифікації. Вона визначає, які ресурси або дії доступні користувачу в системі.",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "19",
      "title": "Назвіть, з яких частин складається HTTP Request та HTTP Response.",
      "body": "HTTP Request складається з: 1. **Стартовий рядок**: містить метод запиту (GET, POST тощо), URL та версію протоколу. 2. **Заголовки**: метадані про запит, такі як тип вмісту, авторизація тощо. 3. **Тіло запиту",
      "category": "General questions",
      "rank": "Junior"
    },
    {
      "id": "20",
      "title": "Для чого потрібні гілки у Git? Як зробити гілку?",
      "body": "Гілки в Git дозволяють розробникам працювати над окремими частинами проєкту незалежно від основної кодової бази. Це сприяє паралельній розробці та спрощує інтеграцію змін. Щоб створити нову гілку, використовуйте команду: git branch <назва_гілки>. Для створення та одночасного переходу на нову гілку: git checkout -b <назва_гілки>.",
      "category": "Git",
      "rank": "Junior"
    },
    {
      "id": "21",
      "title": "Як скопіювати з Git-хостингу (GitHub / GitLab / Bitbucket / інші) проєкт?",
      "body": "Щоб клонувати проєкт із Git-хостингу, виконайте команду: git clone <URL_репозиторію>. Наприклад: git clone https://github.com/користувач/проєкт.git.",
      "category": "Git",
      "rank": "Junior"
    },
    {
      "id": "22",
      "title": "Що таке флаг -f? Для чого він та які мінуси використання?",
      "body": "Прапор -f (force) у Git використовується для примусового виконання команд, які зазвичай можуть бути заблоковані для запобігання втраті даних. Наприклад, git push -f примусово перезаписує зміни на віддаленому репозиторії. Мінуси використання: можливість втрати даних або перезапису роботи інших розробників; порушення історії комітів, що ускладнює відстеження змін. Використовуйте прапор -f обережно та лише тоді, коли впевнені у наслідках.",
      "category": "Git",
      "rank": "Junior"
    },
    {
      "id": "23",
      "title": "Що таке Pull Request? Навіщо гілки поєднують через Pull Request?",
      "body": "Pull Request (PR) — це запит на внесення змін із однієї гілки в іншу, зазвичай із фічевої гілки в основну (main/master). PR дозволяє обговорити зміни з командою, переглянути код (code review) перед інтеграцією, забезпечити контроль якості та узгодженість коду. Поєднання гілок через PR забезпечує прозорість процесу розробки та підвищує якість програмного забезпечення.",
      "category": "Git",
      "rank": "Junior"
    },
    {
      "id": "24",
      "title": "Які ще команди найчастіше застосовуєте, коли користуєтесь Git?",
      "body": "Окрім згаданих, часто використовуються такі команди: git status — перевірка стану робочої директорії та індексу; git add <файл/директорія> — додавання змін до індексу для наступного коміту; git commit -m \"повідомлення\" — фіксація змін із повідомленням; git pull — отримання та злиття змін із віддаленого репозиторію; git push — відправка локальних змін до віддаленого репозиторію; git merge <назва_гілки> — злиття вказаної гілки з поточною; git log — перегляд історії комітів. Ці команди є основними при роботі з Git і забезпечують ефективне керування версіями.",
      "category": "Git",
      "rank": "Junior"
    },
    {
      "id": "25",
      "title": "Які типи змінних є в Ruby?",
      "body": "У Ruby існують такі типи змінних:\n1. **Локальні змінні**: починаються з малої літери або підкреслення (_). Діють лише в межах блоку, методу або класу, де вони оголошені.\n2. **Екземплярні змінні**: починаються з одного символу '@'. Вони є унікальними для кожного об'єкта (екземпляра класу).\n3. **Класові змінні**: починаються з двох символів '@@'. Спільні для всіх екземплярів класу.\n4. **Глобальні змінні**: починаються з символу '$'. Доступні в будь-якому місці програми, але їх використання не рекомендується через можливість непередбачуваних змін.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "26",
      "title": "Що повернеться в результаті складання 10.5 та 10?",
      "body": "У Ruby, якщо скласти 10.5 (число з плаваючою комою) та 10 (ціле число), результатом буде 20.5. Це пояснюється тим, що при виконанні арифметичних операцій між цілим числом та числом з плаваючою комою, ціле число автоматично перетворюється на число з плаваючою комою.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "27",
      "title": "Чим відрізняються змінні, що починаються з @, @@ та $?",
      "body": "У Ruby змінні розрізняються за префіксами:\n- **@variable**: екземплярна змінна, унікальна для кожного об'єкта.\n- **@@variable**: класова змінна, спільна для всіх екземплярів класу.\n- **$variable**: глобальна змінна, доступна в будь-якому місці програми.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "28",
      "title": "Що таке attr_reader, attr_writer, attr_accessor і навіщо вони?",
      "body": "Ці методи використовуються для автоматичного створення геттерів та сеттерів у класах:\n- **attr_reader**: створює метод для читання значення атрибута (геттер).\n- **attr_writer**: створює метод для запису значення атрибута (сеттер).\n- **attr_accessor**: створює як геттер, так і сеттер для атрибута.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "29",
      "title": "Що таке метод?",
      "body": "Метод у Ruby — це набір інструкцій, об'єднаних під спільною назвою, які виконують певну функцію. Методи допомагають організувати код, роблячи його більш структурованим та повторно використовуваним.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "30",
      "title": "Що означає «?» в кінці назви методів? Що означає «!» в кінці назви методів?",
      "body": "У Ruby суфікси «?» та «!» мають спеціальне значення в назвах методів:\n- **«?»**: використовується в методах, які повертають булеве значення, наприклад, `empty?` перевіряє, чи є об'єкт порожнім.\n- **«!»**: позначає методи, які змінюють об'єкт на місці або виконують небезпечні дії. Наприклад, `sort!` сортує масив на місці, змінюючи його вміст.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "31",
      "title": "Чим відрізняється енумератор map від each?",
      "body": "Методи `map` та `each` обидва перебирають елементи колекції, але:\n- **`each`**: виконує заданий блок для кожного елемента, не змінюючи оригінальну колекцію, і повертає її.\n- **`map`**: застосовує блок до кожного елемента, повертаючи нову колекцію з результатами виконання блоку.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "32",
      "title": "Що таке модуль? Які є варіанти під’єднання модулів у клас?",
      "body": "Модуль у Ruby — це набір методів, констант та інших модулів, які можна включати в класи. Модулі не можуть створювати екземпляри, але їх можна підключати до класів за допомогою:\n- **`include`**: додає методи модуля як екземплярні методи класу.\n- **`extend`**: додає методи модуля як класові методи.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "33",
      "title": "Що таке клас і навіщо він потрібен?",
      "body": "Клас у Ruby — це шаблон для створення об'єктів (екземплярів), що визначає їх властивості та поведінку. Класи допомагають організувати код, забезпечуючи об'єктно-орієнтований підхід до програмування.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "34",
      "title": "Що таке модуль і навіщо його використовують? Чим модуль відрізняється від класу?",
      "body": "Модуль — це спосіб групування методів, констант та інших модулів для повторного використання. На відміну від класів, модулі не можуть бути інстанційовані (не можна створити об'єкт модуля) і не підтримують спадкування. Вони використовуються для додавання спільної функціональності до різних класів.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "35",
      "title": "Які типи даних є в Ruby?",
      "body": "У Ruby всі дані представлені у вигляді об'єктів. Основні типи даних включають:\n- **Числа**: цілі числа (`Integer`) та числа з плаваючою комою (`Float`).\n- **Рядки** (`String`): послідовності символів.\n- **Символи** (`Symbol`): унікальні та незмінні ідентифікатори.\n- **Масиви** (`Array`): впорядковані колекції елементів.\n- **Хеші** (`Hash`): невпорядковані колекції пар ключ-значення.\n- **Діапазони** (`Range`): послідовності значень від початкового до кінцевого.\n- **Булеві значення** (`true` та `false`).\n- **nil**: об'єкт, що представляє відсутність значення.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "36",
      "title": "Що таке інтерполяція?",
      "body": "Інтерполяція в Ruby — це процес вставки значення змінної або виразу всередину рядка. Вона здійснюється за допомогою синтаксису `#{вираз}` у подвійних лапках. Наприклад:\n```ruby\nname = \"Світ\"\n\"Привіт, #{name}!\" # => \"Привіт, Світ!\"\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "37",
      "title": "Що таке конкатенація?",
      "body": "Конкатенація — це об'єднання двох або більше рядків в один. У Ruby це можна зробити за допомогою оператора `+` або методу `concat`. Наприклад:\n```ruby\n\"Привіт, \" + \"світе!\" # => \"Привіт, світе!\"\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "38",
      "title": "Що таке масив у Ruby?",
      "body": "Масив (`Array`) у Ruby — це впорядкована колекція елементів, які можуть бути будь-якого типу. Елементи масиву зберігаються у визначеному порядку, і до них можна звертатися за індексом. Наприклад:\n```ruby\n[1, \"два\", 3.0] # Масив з трьох елементів\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "39",
      "title": "Що таке Hash у Ruby? Чим Hash відрізняється від масиву?",
      "body": "Hash у Ruby — це колекція пар ключ-значення, де кожен ключ унікальний. На відміну від масиву, де доступ до елементів здійснюється за індексом, у Hash доступ відбувається за ключем. Наприклад:\n```ruby\n{\n  \"ключ1\" => \"значення1\",\n  :ключ2 => \"значення2\"\n}\n```\nОсновна відмінність між Hash та масивом полягає в тому, що масив впорядкований і доступ до елементів здійснюється за індексом, тоді як Hash не гарантує порядку елементів і доступ відбувається за ключем.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "40",
      "title": "Що таке символ і навіщо він потрібен?",
      "body": "Символ (`Symbol`) у Ruby — це унікальний та незмінний об'єкт, який використовується як ідентифікатор, зазвичай для позначення імен змінних, методів або ключів у Hash. Вони менш ресурсомісткі, ніж рядки, оскільки кожен символ унікальний і зберігається в пам'яті лише один раз. Наприклад:\n```ruby\n:символ\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "41",
      "title": "Що таке Range і навіщо його використовують?",
      "body": "Range (`Діапазон`) у Ruby — це об'єкт, який представляє послідовність значень від початкового до кінцевого. Він використовується для ітерації, перевірки входження значення в діапазон та інших операцій. Наприклад:\n```ruby\n(1..5).each { |i| puts i }\n```\nЦей код виведе числа від 1 до 5.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "42",
      "title": "Що таке Time та Date?",
      "body": "Time та Date — це класи в Ruby для роботи з часом та датами відповідно.\n- **Time**: використовується для представлення конкретного моменту в часі з точністю до секунди. Наприклад:\n```ruby\nTime.now # Повертає поточний час\n```\n- **Date**: використовується для представлення дати без врахування часу доби. Наприклад:\n```ruby\nrequire 'date'\nDate.today # Повертає поточну дату\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "43",
      "title": "Що таке Struct?",
      "body": "Struct у Ruby — це зручний спосіб створення простих класів з атрибутами. Він дозволяє швидко визначити клас з набором атрибутів без явного написання методів ініціалізації та доступу. Наприклад:\n```ruby\nPerson = Struct.new(:name, :age)\nperson = Person.new(\"Аліна\", 30)\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "44",
      "title": "Що таке File?",
      "body": "File у Ruby — це клас для роботи з файлами. Він надає методи для читання, запису, перейменування та видалення файлів. Наприклад, для читання вмісту файлу можна використати:\n```ruby\nFile.read(\"шлях/до/файлу.txt\")\n``` ",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "45",
      "title": "Що таке BasicObject?",
      "body": "`BasicObject` — це найпростіший предок усіх класів у Ruby. Він не включає жодних модулів, таких як `Kernel`, і надає мінімальний набір методів. Це корисно для створення об'єктів з чистим простором імен або для реалізації проксі-об'єктів.  [oai_citation_attribution:0‡ruby-doc.org](https://ruby-doc.org/core-2.7.6/BasicObject.html?utm_source=chatgpt.com)",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "46",
      "title": "Що таке Numeric?",
      "body": "`Numeric` — це абстрактний клас у Ruby, який є предком для всіх числових класів, таких як `Integer`, `Float` та інші. Він визначає базові методи для роботи з числами.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "47",
      "title": "Що таке Enumerable?",
      "body": "`Enumerable` — це модуль, який надає колекціям методи для ітерації, пошуку, сортування та інші. Він включається в класи, які визначають метод `each`, наприклад, `Array` та `Hash`.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "48",
      "title": "Що таке Struct?",
      "body": "`Struct` — це зручний спосіб створення простих класів з атрибутами. Він дозволяє швидко визначити клас з набором атрибутів без явного написання методів ініціалізації та доступу. Наприклад:\n```ruby\nPerson = Struct.new(:name, :age)\nperson = Person.new('Аліна', 30)\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "49",
      "title": "Що таке OpenStruct?",
      "body": "`OpenStruct` — це структура даних, подібна до хешу, яка дозволяє визначати довільні атрибути з їхніми значеннями. Це досягається за допомогою метапрограмування в Ruby, що дозволяє динамічно визначати методи на самому класі.  [oai_citation_attribution:1‡docs.ruby-lang.org](https://docs.ruby-lang.org/en/3.3/OpenStruct.html?utm_source=chatgpt.com)",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "50",
      "title": "Що таке Set?",
      "body": "`Set` — це колекція унікальних елементів без певного порядку. Він забезпечує швидкий доступ до елементів та операції, такі як об'єднання, перетин та різниця.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "51",
      "title": "Що таке Queue?",
      "body": "`Queue` — це клас у Ruby, який реалізує структуру даних «черга». Він забезпечує безпечний для потоків спосіб організації даних у порядку FIFO (First In, First Out).",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "52",
      "title": "Що таке Object?",
      "body": "`Object` — це основний клас у Ruby, від якого наслідуються всі інші класи (окрім `BasicObject`). Він включає в себе модуль `Kernel`, що надає багато корисних методів.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "53",
      "title": "Що таке Kernel?",
      "body": "`Kernel` — це модуль, який надає багато основних методів, доступних у всіх об'єктах Ruby. Він включений в клас `Object`, що робить його методи доступними безпосередньо в будь-якому місці програми.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "54",
      "title": "Чи є інтерфейси в Ruby?",
      "body": "У Ruby немає інтерфейсів у традиційному розумінні, як у мовах Java або C#. Замість цього Ruby використовує динамічну типізацію та міксини (модулі), які дозволяють додавати функціональність до класів. Це забезпечує гнучкість та полегшує повторне використання коду.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "55",
      "title": "Що таке getter і setter в Ruby? Як їх створювати?",
      "body": "Getter і setter — це методи доступу до змінних об'єкта. У Ruby їх можна створити вручну або за допомогою методів `attr_reader`, `attr_writer` та `attr_accessor`.\n\n```ruby\nclass Person\n  attr_accessor :name\nend\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "56",
      "title": "Що таке інстансна змінна?",
      "body": "Інстансна змінна (instance variable) — це змінна, яка належить конкретному об'єкту і починається з символу `@`. Вона зберігає стан об'єкта і доступна лише в межах цього об'єкта.\n\n```ruby\nclass Person\n  def initialize(name)\n    @name = name\n  end\nend\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "57",
      "title": "Що таке константа класу?",
      "body": "Константа класу — це змінна, яка визначається в класі і зазвичай пишеться великими літерами. Вона зберігає значення, яке не повинно змінюватися, хоча Ruby дозволяє змінювати константи з попередженням.\n\n```ruby\nclass MyClass\n  CONSTANT = 'value'\nend\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "58",
      "title": "Яка різниця між методом класу і методом об’єкта?",
      "body": "Метод об'єкта викликається на екземплярі класу, тоді як метод класу викликається безпосередньо на самому класі.\n\n```ruby\nclass MyClass\n  def self.class_method\n    # метод класу\n  end\n\n  def instance_method\n    # метод об'єкта\n  end\nend\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "59",
      "title": "Які є області видимості?",
      "body": "У Ruby є чотири основні області видимості: локальна, інстансна, класова та глобальна. Локальні змінні доступні лише в межах блоку або методу, інстансні — в межах об'єкта, класові — спільні для всіх екземплярів класу, а глобальні доступні в усьому просторі програми.\n\n```ruby\n$global_var = 'глобальна'\n@instance_var = 'інстансна'\n@@class_var = 'класова'\nlocal_var = 'локальна'\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "60",
      "title": "Які є модифікатори доступу? Як private відрізняється від protected?",
      "body": "У Ruby є три модифікатори доступу: public, protected та private. Методи, оголошені як private, можуть бути викликані лише в межах того ж об'єкта, тоді як protected-методи можуть бути викликані в межах того ж класу або підкласу.\n\n```ruby\nclass MyClass\n  def public_method\n    # публічний метод\n  end\n\n  protected\n\n  def protected_method\n    # захищений метод\n  end\n\n  private\n\n  def private_method\n    # приватний метод\n  end\nend\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "61",
      "title": "Чи підтримує Ruby множинне спадкування?",
      "body": "Ruby не підтримує множинне спадкування класів, але дозволяє включати модулі (міксини) до класів, що забезпечує подібну функціональність. Це дозволяє додавати методи з кількох модулів до одного класу.\n\n```ruby\nmodule A\n  def method_a\n    # метод з модуля A\n  end\nend\n\nmodule B\n  def method_b\n    # метод з модуля B\n  end\nend\n\nclass MyClass\n  include A\n  include B\nend\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "62",
      "title": "Як успадковуються методи? Чи можна перевизначити метод?",
      "body": "Методи в Ruby успадковуються від батьківського класу до підкласу. Підклас може перевизначити метод батьківського класу, надаючи свою реалізацію.\n\n```ruby\nclass Parent\n  def greet\n    'Hello from Parent'\n  end\nend\n\nclass Child < Parent\n  def greet\n    'Hello from Child'\n  end\nend\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "63",
      "title": "Навіщо метод super?",
      "body": "Метод `super` використовується для виклику методу з такою ж назвою в батьківському класі. Це дозволяє підкласу розширювати або змінювати поведінку батьківського методу, зберігаючи його оригінальну функціональність.\n\n```ruby \nclass Parent\n  def greet\n    'Hello from Parent'\n  end\nend\n\nclass Child < Parent\n  def greet\n    super + ' and Child'\n  end\nend\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "64",
      "title": "Що таке Singleton-метод?",
      "body": "Singleton-метод у Ruby — це метод, який визначається для конкретного об'єкта, а не для всіх екземплярів класу. Це дозволяє додавати унікальну поведінку окремим об'єктам.  [oai_citation_attribution:0‡GeeksforGeeks](https://www.geeksforgeeks.org/ruby-singleton-methods/?utm_source=chatgpt.com)\n\n```ruby\nstr = \"Hello\"\n\ndef str.shout\n  self.upcase + \"!\"\nend\n\nputs str.shout # Виведе: HELLO!\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "65",
      "title": "Що таке міксини? Навіщо вони і чим відрізняються від декоратора?",
      "body": "Міксини в Ruby — це модулі, які додають функціональність до класів через включення (include) або розширення (extend). Вони дозволяють ділитися поведінкою між класами без необхідності спадкування.  [oai_citation_attribution:1‡Сучасний підручник з JavaScript](https://uk.javascript.info/mixins?utm_source=chatgpt.com)\n\nДекоратори, з іншого боку, — це патерн проєктування, який динамічно додає поведінку об'єктам шляхом обгортання їх у спеціальні класи.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "66",
      "title": "Що таке include та extend і в чому різниця між ними?",
      "body": "У Ruby `include` та `extend` використовуються для додавання методів модулів до класів або об'єктів.\n\n- `include` додає методи модуля як інстансні методи класу.\n- `extend` додає методи модуля як методи класу або як singleton-методи об'єкта.\n\n```ruby\nmodule Greetings\n  def hello\n    \"Hello!\"\n  end\nend\n\nclass Person\n  include Greetings\nend\n\np = Person.new\nputs p.hello # Виведе: Hello!\n\nclass Animal\n  extend Greetings\nend\n\nputs Animal.hello # Виведе: Hello!\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "67",
      "title": "Який шлях пошуку методу в ієрархії класів?",
      "body": "У Ruby пошук методу відбувається в такому порядку:\n\n1. Singleton-клас об'єкта (якщо є).\n2. Власний клас об'єкта.\n3. Включені модулі (міксини) у порядку їх включення.\n4. Батьківські класи вгору по ієрархії.\n5. Клас `BasicObject` як остання інстанція.\n\nЯкщо метод не знайдено, викликається метод `method_missing`.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "68",
      "title": "Яка різниця між послідовними та іменованими аргументами методу?",
      "body": "У Ruby методи можуть приймати два типи аргументів:\n\n- **Послідовні аргументи** передаються в певному порядку, і їх позиція має значення.\n- **Іменовані аргументи** передаються як хеш і не залежать від порядку.\n\n```ruby\ndef greet(name, age:)\n  \"Hello, #{name}. You are #{age} years old.\"\nend\n\nputs greet(\"Alice\", age: 30) # Виведе: Hello, Alice. You are 30 years old.\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "69",
      "title": "Що таке exception? Коли вони застосовуються? Як викликати exception? Як відловити exception?",
      "body": "Exception (виключення) — це механізм обробки помилок у Ruby, який дозволяє керувати непередбаченими ситуаціями під час виконання програми.\n\n- **Застосування:** Виключення використовуються для обробки помилок, таких як ділення на нуль, відсутність файлу або неправильний ввід користувача.\n- **Виклик exception:** Для виклику виключення використовується ключове слово `raise`.\n- **Відловлювання exception:** Для обробки виключень використовується блок `begin...rescue`.\n\n```ruby\nbegin\n  # Код, який може викликати виключення\n  result = 10 / 0\nrescue ZeroDivisionError => e\n  puts \"Помилка: #{e.message}\"\nend\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "70",
      "title": "Що означає open class?",
      "body": "У Ruby класи є \"відкритими\", що означає можливість повторно відкривати існуючі класи для додавання або зміни методів. Це дозволяє розширювати або змінювати функціональність класів без необхідності успадкування. Наприклад:\n\n```ruby\nclass String\n  def shout\n    self.upcase + \"!\"\n  end\nend\n\nputs \"hello\".shout # Виведе: HELLO!\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "71",
      "title": "Що таке monkey patching?",
      "body": "Monkey patching — це практика динамічної зміни або розширення існуючих класів або модулів під час виконання програми. Це дозволяє змінювати поведінку бібліотек або фреймворків без зміни їх початкового коду. Хоча це може бути корисним, неправильне використання monkey patching може призвести до непередбачуваної поведінки та конфліктів у коді.  [oai_citation_attribution:0‡GeeksforGeeks](https://www.geeksforgeeks.org/monkey-patching-in-ruby/?utm_source=chatgpt.com)",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "72",
      "title": "Чи можливо створити клас динамічно? Якщо так, то як саме?",
      "body": "Так, у Ruby можна динамічно створювати класи за допомогою методу `Class.new`. Наприклад:\n\n```ruby\nMyClass = Class.new do\n  def hello\n    \"Привіт!\"\n  end\nend\n\nobj = MyClass.new\nputs obj.hello # Виведе: Привіт!\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "73",
      "title": "Які є способи динамічного керування методами, змінними та класами (define_method(), class_eval(), module_eval())?",
      "body": "У Ruby є кілька методів для динамічного керування:\n\n- `define_method`: дозволяє визначати методи динамічно.\n- `class_eval` та `module_eval`: дозволяють виконувати код у контексті класу або модуля, додаючи методи або змінні.\n\n```ruby\nclass MyClass\n  define_method(:greet) do |name|\n    \"Привіт, #{name}!\"\n  end\nend\n\nMyClass.class_eval do\n  def farewell(name)\n    \"До побачення, #{name}!\"\n  end\nend\n\nobj = MyClass.new\nputs obj.greet(\"Аліса\") # Виведе: Привіт, Аліса!\nputs obj.farewell(\"Аліса\") # Виведе: До побачення, Аліса!\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "74",
      "title": "Як відбувається пошук методу в ієрархії? Як можна опрацювати відсутність методу (method_missing())?",
      "body": "Пошук методу в Ruby відбувається в такому порядку:\n\n1. Singleton-методи об'єкта.\n2. Методи в класі об'єкта.\n3. Методи в модулях, включених у клас (у порядку включення).\n4. Методи в суперкласах (вгору по ієрархії).\n5. Методи в класі `BasicObject`.\n\nЯкщо метод не знайдено, викликається метод `method_missing`, який можна перевизначити для обробки викликів невизначених методів.\n\n```ruby\nclass MyClass\n  def method_missing(method_name, *args, &block)\n    puts \"Метод '#{method_name}' не знайдено.\"\n  end\nend\n\nobj = MyClass.new\nobj.unknown_method # Виведе: Метод 'unknown_method' не знайдено.\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "75",
      "title": "Що таке аліас методу? Для чого потрібні аліаси?",
      "body": "Аліас методу — це альтернативна назва для існуючого методу. Вони використовуються для збереження старої версії методу перед його зміною або для надання більш зрозумілої назви методу.\n\n```ruby\nclass MyClass\n  def original_method\n    \"Це оригінальний метод.\"\n  end\n\n  alias :new_method :original_method\nend\n\nobj = MyClass.new\nputs obj.new_method # Виведе: Це оригінальний метод.\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "76",
      "title": "Як отримати значення інстансної змінної? Як задати значення? Як перевірити існування інстансної змінної (instance_variable_get(), instance_variable_set(), instance_variable_defined?)?",
      "body": "У Ruby для роботи з інстансними змінними використовуються такі методи:\n\n- `instance_variable_get`: отримує значення інстансної змінної.\n- `instance_variable_set`: встановлює значення інстансної змінної.\n- `instance_variable_defined?`: перевіряє, чи існує інстансна змінна.\n\n```ruby\nclass MyClass\n  def initialize\n    @my_var = 42\n  end\nend\n\nobj = MyClass.new\n\n# Отримання значення\nputs obj.instance_variable_get(:@my_var) # Виведе: 42\n\n# Встановлення значення\nobj.instance_variable_set(:@my_var, 100)\nputs obj.instance_variable_get(:@my_var) # Виведе: 100\n\n# Перевірка існування\nputs obj.instance_variable_defined?(:@my_var) # Виведе: true\n```",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "77",
      "title": "Які методи інтроспекції є в Ruby (class(), ancestors(), methods(), private_methods(), instance_variables(), singleton_methods(), local_variables())?",
      "body": "Ruby надає різні методи для інтроспекції:\n\n- `class`: повертає клас об'єкта.\n- `ancestors`: повертає список предків модуля або класу.\n- `",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "78",
      "title": "Що таке хуки й навіщо їх використовують (inherited(), included(), method_added(), singleton_method_added(), method_missing())?",
      "body": "У Ruby хуки — це спеціальні методи, які автоматично викликаються системою в певних ситуаціях, дозволяючи розробникам втручатися в поведінку програми на різних етапах її виконання. Вони широко використовуються для метапрограмування, надаючи можливість динамічно змінювати або розширювати функціональність програм.\n\n**Основні хуки в Ruby:**\n\n1. **`inherited(subclass)`**: Викликається, коли клас успадковується. Це дозволяє базовому класу реагувати на створення підкласів.\n\n   ```ruby\n   class Base\n     def self.inherited(subclass)\n       puts \"#{subclass} успадковує від #{self}\"\n     end\n   end\n\n   class Derived < Base\n   end\n   # Виведе: Derived успадковує від Base\n   ```\n\n2. **`included(base)`**: Викликається, коли модуль включається в клас або інший модуль за допомогою `include`. Це дозволяє модулю виконувати додаткові дії під час включення.\n\n   ```ruby\n   module MyModule\n     def self.included(base)\n       puts \"#{base} включає #{self}\"\n     end\n   end\n\n   class MyClass\n     include MyModule\n   end\n   # Виведе: MyClass включає MyModule\n   ```\n\n3. **`method_added(method_name)`**: Викликається щоразу, коли до класу додається новий метод. Це корисно для відстеження або модифікації методів під час їх додавання.\n\n   ```ruby\n   class MyClass\n     def self.method_added(method_name)\n       puts \"Додано метод: #{method_name}\"\n     end\n\n     def new_method\n     end\n     # Виведе: Додано метод: new_method\n   end\n   ```\n\n4. **`singleton_method_added(method_name)`**: Викликається, коли до об'єкта додається синглтон-метод (метод, який належить конкретному екземпляру). Це дозволяє відстежувати додавання методів до окремих об'єктів.\n\n   ```ruby\n   obj = Object.new\n\n   def obj.singleton_method_added(method_name)\n     puts \"Додано синглтон-метод: #{method_name}\"\n   end\n\n   def obj.new_singleton_method\n   end\n   # Виведе: Додано синглтон-метод: new_singleton_method\n   ```\n\n5. **`method_missing(method_name, *args, &block)`**: Викликається, коли об'єкт не має методу з заданим ім'ям. Це дозволяє реалізовувати динамічні методи або обробляти виклики до неіснуючих методів.\n\n   ```ruby\n   class MyClass\n     def method_missing(method_name, *args, &block)\n       puts \"Метод #{method_name} не знайдено, але ми можемо обробити це!\"\n     end\n   end\n\n   obj = MyClass.new\n   obj.non_existent_method\n   # Виведе: Метод non_existent_method не знайдено, але ми можемо обробити це!\n   ```\n\nВикористання хуків надає розробникам гнучкість у налаштуванні поведінки програм, дозволяючи реагувати на певні події та динамічно змінювати функціональність.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "79",
      "title": "Що таке gem? Що таке RubyGems?",
      "body": "У Ruby, **gem** — це пакет, який містить бібліотеку або програму, що розширює функціональність мови. **RubyGems** — це менеджер пакетів для Ruby, який дозволяє легко встановлювати, оновлювати та керувати такими пакетами.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "80",
      "title": "З якою метою використовують RVM? Що таке gemset?",
      "body": "**RVM** (Ruby Version Manager) — це інструмент, який дозволяє керувати кількома версіями Ruby на одному комп'ютері, переключатися між ними та ізолювати середовища для різних проектів. **Gemset** у RVM — це ізольоване середовище для набору gem'ів, що дозволяє уникнути конфліктів між залежностями різних проектів.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "81",
      "title": "Що таке Bundler і навіщо він?",
      "body": "**Bundler** — це інструмент для керування залежностями у Ruby-проектах. Він забезпечує встановлення потрібних версій gem'ів, необхідних для роботи проекту, та гарантує, що всі залежності будуть задоволені.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "82",
      "title": "Що таке Gemfile і для чого його використовують?",
      "body": "**Gemfile** — це файл у кореневій директорії Ruby-проекту, який містить список усіх gem'ів та їх версій, необхідних для роботи цього проекту. Bundler використовує цей файл для встановлення та керування залежностями проекту.",
      "category": "Ruby",
      "rank": "Junior"
    },
    {
      "id": "83",
      "title": "Що таке MVC? Чи є Rails MVC-фреймворком?",
      "body": "**MVC (Model-View-Controller)** — це архітектурний шаблон, який розділяє застосунок на три основні компоненти:\n- **Model (Модель)**: відповідає за управління даними та бізнес-логікою.\n- **View (Представлення)**: відповідає за відображення даних користувачеві.\n- **Controller (Контролер)**: обробляє запити користувача, взаємодіє з моделлю та визначає, яке представлення відобразити.\n**Ruby on Rails** є MVC-фреймворком, оскільки він реалізує цей шаблон, що сприяє структурованому та організованому підходу до розробки веб-застосунків.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "84",
      "title": "Що таке міграція? Для чого вона потрібна? Які є правила створення міграцій?",
      "body": "**Міграція** в Rails — це спосіб зміни структури бази даних у контрольований та версіонований спосіб. Вона дозволяє додавати або змінювати таблиці та їх стовпці безпосередньо з коду, що спрощує підтримку та розвиток застосунку. При створенні міграцій слід дотримуватися наступних правил:\n1. Назви міграцій повинні бути інформативними та описувати зміни (наприклад, `AddEmailToUsers`).\n2. Використовуйте методи `change`, `up` та `down` для визначення змін та можливості їх відкату.\n3. Після створення міграції необхідно виконати її за допомогою команди `rails db:migrate`.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "85",
      "title": "Що таке роути? Що таке resource та resources в роутах?",
      "body": "**Роути (маршрути)** в Rails визначають, як URL-запити спрямовуються до відповідних контролерів та їх дій. Вони налаштовуються у файлі `config/routes.rb`. Ключові поняття:\n- **resource**: визначає маршрути для одного ресурсу, надаючи стандартні дії (`show`, `new`, `create`, `edit`, `update`, `destroy`).\n- **resources**: визначає маршрути для колекції ресурсів, включаючи дії `index` та `show` для окремих елементів.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "86",
      "title": "Чим відрізняється has_many through від has_and_belongs_to_many?",
      "body": "Обидва методи встановлюють зв'язки між моделями:\n- **`has_many :through`**: використовується для зв'язків багато-до-багатьох через проміжну модель, що дозволяє додавати додаткові атрибути та логіку до зв'язку.\n- **`has_and_belongs_to_many`**: встановлює прямий зв'язок багато-до-багатьох без проміжної моделі, але не дозволяє додавати атрибути до зв'язку.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "87",
      "title": "Навіщо використовують concerns?",
      "body": "**Concerns** в Rails дозволяють організувати та повторно використовувати код, що спільний для кількох моделей або контролерів. Вони сприяють дотриманню принципу DRY (Don't Repeat Yourself) та покращують структуру коду.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "88",
      "title": "Як працювати із sensitive-даними в Rails-застосунках (токени, ключі тощо)? Як працює механізм credentials в Rails?",
      "body": "Для безпечного зберігання конфіденційних даних (токенів, ключів) в Rails-застосунках використовується механізм **credentials**. Він дозволяє зберігати такі дані в зашифрованому файлі `config/credentials.yml.enc`, доступ до якого можливий лише за наявності ключа `master.key`. Це забезпечує безпеку та зручність управління конфіденційною інформацією.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "89",
      "title": "З якою метою використовують локалі (locals)?",
      "body": "**Локалі (locals)** в Rails використовуються для передачі змінних від контролера до представлення. Вони дозволяють динамічно відображати дані у вигляді, забезпечуючи гнучкість та налаштовуваність інтерфейсу користувача.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "90",
      "title": "З чого складається Rails-застосунок? Яка архітектура директорій? Навіщо потрібна кожна з них?",
      "body": "Rails-застосунок має чітко визначену структуру директорій, кожна з яких виконує свою роль:\n- **app/**: містить основний код застосунку, включаючи моделі, контролери, представлення та інші компоненти.\n- **bin/**: містить виконувані файли, такі як `rails` та інші скрипти.\n- **config/**: зберігає конфігураційні файли застосунку, включаючи маршрути, налаштування бази даних тощо.\n- **db/**: містить файли, пов'язані з базою даних, такі як міграції та схеми.\n- **lib/**: використовується для зберігання власних бібліотек та модулів, які не входять до стандартного функціоналу.\n- **log/**: містить файли журналів роботи застосунку.\n- **public/**: зберігає статичні файли, такі як зображення, JavaScript та CSS, які доступні безпосередньо.\n- **test/** або **spec/**: містить тести для застосунку.\n- **tmp/**: використовується для тимчасових файлів.\n- **vendor/**: зберігає сторонні бібліотеки та плагіни, які не встановлюються через gem.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "91",
      "title": "Чим відрізняється lib від vendor?",
      "body": "Директорії **lib/** та **vendor/** в Rails мають різне призначення:\n- **lib/**: використовується для зберігання власних бібліотек, модулів та класів, розроблених спеціально для цього застосунку.\n- **vendor/**: призначена для зберігання сторонніх бібліотек та плагінів, які не встановлюються через gem, але необхідні для роботи застосунку.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "92",
      "title": "Як створити background job в Rails?",
      "body": "Для створення фонових завдань (background jobs) в Rails часто використовують бібліотеки, такі як Sidekiq або Delayed Job. Процес створення фонової задачі включає:\n1. **Встановлення гемів**: додайте необхідні геми до вашого Gemfile та виконайте `bundle install`.\n2. **Створення задачі**: згенеруйте клас задачі за допомогою відповідної команди, наприклад, `rails generate job MyJob`.\n3. **Визначення логіки**: реалізуйте метод `perform` у створеному класі, де буде описана логіка виконання задачі.\n4. **Виклик задачі**: заплануйте виконання задачі, використовуючи методи, надані обраною бібліотекою.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "93",
      "title": "Які є способи завантаження асоціацій у Rails?",
      "body": "У Rails існують різні способи завантаження асоціацій між моделями:\n- **Ліниве завантаження (Lazy Loading)**: асоціації завантажуються під час першого доступу до них. Це може призвести до надмірної кількості запитів до бази даних (N+1 проблема).\n- **Жадібне завантаження (Eager Loading)**: асоціації завантажуються разом з основним об'єктом за допомогою методів `includes` або `joins`, що зменшує кількість запитів до бази даних.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "94",
      "title": "Навіщо потрібні моделі? Чим є модель?",
      "body": "Моделі в Ruby on Rails представляють бізнес-логіку та дані застосунку. Вони відповідають за взаємодію з базою даних, забезпечуючи об'єктно-орієнтований інтерфейс для роботи з даними.",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "95",
      "title": "Що таке ORM? Що таке ActiveRecord?",
      "body": "ORM (Object-Relational Mapping) — це технологія, яка дозволяє відображати об'єкти програмного коду на записи в реляційній базі даних. ActiveRecord — це реалізація ORM в Ruby on Rails, яка забезпечує інтуїтивний спосіб виконання запитів до бази даних без прямого використання SQL.  [oai_citation_attribution:0‡https://rubydevelopers.org](https://rubydevelopers.org/t/activerecord/91?utm_source=chatgpt.com)",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "96",
      "title": "Які є правила найменування моделей і таблиць у базі даних?",
      "body": "У Rails моделі називаються в однині з використанням CamelCase (наприклад, `User`), а відповідні таблиці в базі даних — у множині з використанням snake_case (наприклад, `users`).",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "97",
      "title": "Що таке міграції та навіщо потрібен цей механізм? Як створювати міграції?",
      "body": "Міграції в Rails — це спосіб керування змінами в структурі бази даних. Вони дозволяють додавати або змінювати таблиці та колонки в базі даних, зберігаючи історію змін. Міграції створюються за допомогою генератора командою `rails generate migration НазваМіграції`.",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "98",
      "title": "Які види валідацій є в ActiveRecord?",
      "body": "ActiveRecord надає різні вбудовані методи валідації, такі як `validates_presence_of`, `validates_uniqueness_of`, `validates_length_of` та інші, які дозволяють перевіряти коректність даних перед їх збереженням у базу даних.  [oai_citation_attribution:1‡Ruby on Rails Guides](https://guides.rubyonrails.org/v3.2.0/active_record_validations_callbacks.html?utm_source=chatgpt.com)",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "99",
      "title": "Як можна викликати валідацію? Коли валідація викликається автоматично? Як можна вимкнути валідацію під час збереження?",
      "body": "Валідації в ActiveRecord викликаються автоматично під час виклику методів `save`, `create` або `update`. Для ручного виклику валідацій можна використовувати метод `valid?`. Щоб зберегти об'єкт без виконання валідацій, можна використовувати метод `save(validate: false)`.",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "100",
      "title": "Що таке callback в Rails?",
      "body": "Callbacks (зворотні виклики) в Rails — це методи, які викликаються в певні моменти життєвого циклу об'єкта, такі як перед або після збереження, оновлення або видалення запису.  [oai_citation_attribution:2‡Ruby on Rails Guides](https://guides.rubyonrails.org/v3.2.0/active_record_validations_callbacks.html?utm_source=chatgpt.com)",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "101",
      "title": "Які є види колбеків в ActiveRecord?",
      "body": "ActiveRecord підтримує різні види колбеків, такі як `before_save`, `after_save`, `before_create`, `after_create`, `before_update`, `after_update`, `before_destroy`, `after_destroy` та інші, які дозволяють виконувати певний код у відповідні моменти життєвого циклу об'єкта.  [oai_citation_attribution:3‡Ruby on Rails Guides](https://guides.rubyonrails.org/v3.2.0/active_record_validations_callbacks.html?utm_source=chatgpt.com)",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "102",
      "title": "Які види асоціацій є в ActiveRecord?",
      "body": "ActiveRecord підтримує кілька типів асоціацій між моделями, включаючи `belongs_to`, `has_one`, `has_many`, `has_many :through`, `has_one :through` та `has_and_belongs_to_many`.",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "103",
      "title": "Що таке has_one і belongs_to?",
      "body": "`belongs_to` вказує на те, що модель належить іншій моделі. `has_one` вказує на те, що модель має один пов'язаний запис в іншій моделі.",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "104",
      "title": "Що таке has_many?",
      "body": "`has_many` вказує на те, що модель має багато пов'язаних записів в іншій моделі.",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "105",
      "title": "Що таке has_many :through?",
      "body": "`has_many :through` встановлює асоціацію багато-до-багатьох через третю модель, яка виступає як сполучна ланка між двома іншими моделями.",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "106",
      "title": "Що таке has_and_belongs_to_many?",
      "body": "Асоціація `has_and_belongs_to_many` в Rails використовується для встановлення зв'язку багато-до-багатьох між двома моделями без проміжної моделі. Ця асоціація вимагає наявності таблиці зв'язку з двома зовнішніми ключами. Вона підходить, коли вам не потрібно додатково працювати з самою асоціацією як окремим об'єктом. Для більш складних випадків, коли потрібна додаткова інформація про зв'язок, рекомендується використовувати асоціацію `has_many :through`. [rails guides](https://guides.rubyonrails.org/association_basics.html)",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "107",
      "title": "Що таке поліморфна асоціація?",
      "body": "Поліморфна асоціація в Rails дозволяє одній моделі бути асоційованою з кількома іншими моделями через одну асоціацію. Це досягається за допомогою двох колонок: `association_type` та `association_id`, які зберігають тип та ідентифікатор пов'язаної моделі. Наприклад, модель `Comment` може бути пов'язана як з `Post`, так і з `Photo` через поліморфну асоціацію. [rails guides](https://guides.rubyonrails.org/association_basics.html)",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "108",
      "title": "Що таке STI?",
      "body": "Single Table Inheritance (STI) — це патерн проектування в Rails, який дозволяє зберігати об'єкти різних класів у одній таблиці бази даних. Для цього додається колонка `type`, яка визначає клас кожного об'єкта. Це зручно, коли об'єкти мають спільні атрибути та поведінку, але також мають специфічні відмінності. [rails guides](https://guides.rubyonrails.org/association_basics.html)",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "109",
      "title": "Яким чином можна отримати дані з бази даних? Як отримати один об’єкт і колекцію? Як задати умови вибірки?",
      "body": "У Rails для отримання даних з бази даних використовуються методи ActiveRecord. Щоб отримати один об'єкт, використовуйте методи `find` або `find_by`, наприклад: `User.find(1)` або `User.find_by(name: 'Alice')`. Для отримання колекції об'єктів використовуйте методи `all`, `where`, `order` тощо, наприклад: `User.where(active: true).order(:created_at)`. Для задання умов вибірки передавайте хеш параметрів у метод `where`, що відповідає умовам SQL-запиту. [rails guides](https://guides.rubyonrails.org/active_record_querying.html)",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "110",
      "title": "Що таке скоупи? Яка їхня функція?",
      "body": "Скоупи в Rails — це методи, які дозволяють інкапсулювати часто використовувані запити до бази даних в моделі. Вони покращують читабельність та повторне використання коду. Скоупи визначаються як методи в моделі, які зазвичай повертають об'єкти ActiveRecord::Relation, дозволяючи ланцюгове викликанння. Наприклад: `scope :active, -> { where(active: true) }`. [rails guides](https://guides.rubyonrails.org/active_record_querying.html)",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "111",
      "title": "Як виконати довільний SQL-запит?",
      "body": "У Rails для виконання довільного SQL-запиту можна використовувати метод `find_by_sql` або `connection.execute`. Наприклад: `User.find_by_sql('SELECT * FROM users WHERE active = ?', [true])`. Однак слід бути обачним при використанні довільних запитів, щоб уникнути SQL-ін'єкцій та інших проблем безпеки. [rails guides](https://guides.rubyonrails.org/active_record_querying.html)",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "112",
      "title": "Як подивитися інформацію про те, як виконувався запит, які використовувалися ключі тощо?",
      "body": "У Rails для перегляду виконуваних SQL-запитів та їх планів можна використовувати метод `explain` на об'єкті ActiveRecord::Relation. Наприклад: `User.where(active: true).explain`. Це дозволить побачити план виконання запиту, включаючи використані індекси та інші деталі. Також можна переглянути лог запитів, який зазвичай знаходиться в файлі `log/development.log`. [rails guides](https://guides.rubyonrails.org/active_record_querying.html)",
      "category": "ActiveRecord",
      "rank": "Junior"
    },
    {
      "id": "113",
      "title": "Що таке контролер? Яке завдання виконує?",
      "body": "Контролер у Ruby on Rails — це клас, який обробляє HTTP-запити від користувача, взаємодіє з моделями для отримання або оновлення даних та передає ці дані у відповідні представлення для відображення. Він виконує роль посередника між моделями та представленнями, забезпечуючи обробку запитів і відповіді.  [oai_citation_attribution:0‡Ruby on Rails Guides](https://guides.rubyonrails.org/action_controller_overview.html?utm_source=chatgpt.com)",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "114",
      "title": "Що таке action? Що таке CRUD action?",
      "body": "У Rails, action (дія) — це метод у контролері, який відповідає за обробку конкретного HTTP-запиту. CRUD-дії (Create, Read, Update, Delete) є стандартними діями для роботи з ресурсами:\n\n- **Create**: створення нового запису.\n- **Read**: читання або перегляд записів.\n- **Update**: оновлення існуючого запису.\n- **Delete**: видалення запису.\n\nЦі дії відповідають за виконання відповідних операцій над даними в додатку.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "115",
      "title": "Що таке permit params?",
      "body": "У Rails, метод `permit` використовується для безпечного доступу до параметрів, які надходять у запиті. Це частина механізму 'strong parameters', який захищає від небажаних або небезпечних даних. Використовуючи `permit`, ви вказуєте, які параметри є допустимими для обробки.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "116",
      "title": "Що таке ActiveRecord? Як він реалізований в Rails-фреймворку?",
      "body": "ActiveRecord — це бібліотека в Rails, яка реалізує патерн Active Record для роботи з базою даних. Вона забезпечує об'єктно-реляційне відображення (ORM), дозволяючи розробникам працювати з базою даних за допомогою об'єктів Ruby замість написання SQL-запитів. ActiveRecord автоматично відображає моделі на таблиці бази даних, забезпечуючи зручний інтерфейс для маніпуляції даними.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "117",
      "title": "Що таке параметри? Як вони потрапляють у контролер? Що таке дефолтні параметри (в роутах)? Що таке стронг-параметри?",
      "body": "**Параметри** — це дані, які надходять з HTTP-запиту (наприклад, з форми або URL) і передаються в контролер для обробки.\n\n**Як вони потрапляють у контролер?** — Параметри з запиту автоматично доступні в об'єкті `params` у контролері.\n\n**Дефолтні параметри в роутах** — У файлі `config/routes.rb` можна визначити значення за замовчуванням для параметрів, які використовуються в маршрутах.\n\n**Стронг-параметри** — Це механізм у Rails, який вимагає явного переліку дозволених параметрів для запобігання небажаним або небезпечним даним.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "118",
      "title": "Що таке cookies і навіщо вони? Де зберігаються cookies? Як отримати доступ до cookies?",
      "body": "**Cookies** — це невеликі фрагменти даних, які веб-сервер надсилає браузеру користувача для зберігання інформації між запитами, наприклад, для збереження стану сесії. В Rails, доступ до cookies здійснюється через об'єкт `cookies`, який дозволяє читати та записувати значення.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "119",
      "title": "Що таке сесії та в чому їхнє завдання? Де зберігаються сесії? Як отримати доступ до сесії?",
      "body": "**Сесії** в Rails використовуються для зберігання даних про користувача між запитами, наприклад, для збереження інформації про авторизацію. За замовчуванням, дані сесії зберігаються на стороні клієнта у зашифрованих cookies. Доступ до сесії в контролері здійснюється через об'єкт `session`.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "120",
      "title": "Які види фільтрів є в Rails? (before / after / around actions)",
      "body": "У Rails є три основні види фільтрів:\n\n- **before_action**: методи, які виконуються перед виконанням дії контролера.\n- **after_action**: методи, які виконуються після виконання дії контролера.\n- **around_action**: методи, які обгортають виконання дії контролера, дозволяючи виконати код до та після дії.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "121",
      "title": "Навіщо потрібен об’єкт Request? Яку інформацію він містить?",
      "body": "Об'єкт `Request` в Rails надає доступ до інформації про HTTP-запит, включаючи параметри запиту, заголовки, метод запиту (GET, POST тощо), URL та інші дані, що надходять від клієнта.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "122",
      "title": "Для чого потрібен об’єкт Response? Яку інформацію він містить?",
      "body": "Об'єкт `Response` в Rails відповідає за формування HTTP-відповіді, включаючи статус-код, заголовки, тіло відповіді та інші параметри, які надсилаються клієнту.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "123",
      "title": "Що таке Rescue в контролерах і для чого застосовується?",
      "body": "У Ruby on Rails, метод `rescue_from` використовується в контролерах для обробки виключень (exceptions). Це дозволяє централізувати обробку помилок, забезпечуючи чистий та зрозумілий код. За допомогою `rescue_from` можна перехоплювати специфічні виключення та визначати відповідні дії, наприклад, перенаправлення користувача на сторінку з повідомленням про помилку. Це підвищує надійність та зручність використання веб-додатку.  [oai_citation_attribution:0‡Ruby on Rails Guides](https://guides.rubyonrails.org/?utm_source=chatgpt.com)",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "124",
      "title": "Як примусово увімкнути використання HTTPS-протоколу?",
      "body": "Щоб примусово увімкнути використання HTTPS-протоколу в додатку Ruby on Rails, необхідно виконати кілька кроків:\n1. **Налаштування серверу**: Переконайтеся, що ваш веб-сервер (наприклад, Nginx або Apache) налаштований на обробку HTTPS-запитів та має дійсний SSL-сертифікат.\n2. **Налаштування Rails**: У файлі конфігурації `config/environments/production.rb` додайте або розкоментуйте наступний рядок:\n```ruby\n config.force_ssl = true\n ```\n Це забезпечить автоматичне перенаправлення всіх HTTP-запитів на HTTPS.\n 3. **Оновлення маршрутів**: Переконайтеся, що всі зовнішні посилання та ресурси використовують HTTPS-протокол.\n Ці кроки допоможуть забезпечити безпечне з'єднання між клієнтом та сервером, захищаючи дані від можливих атак.  [oai_citation_attribution:1‡Ruby on Rails Guides](https://guides.rubyonrails.org/?utm_source=chatgpt.com)",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "125",
      "title": "Що таке роути і в чому їхня функція?",
      "body": "**Роути** (маршрути) в Ruby on Rails відповідають за визначення відповідності між вхідними HTTP-запитами та діями контролерів. Вони визначають, як URL-шляхи та HTTP-методи (GET, POST, PATCH, DELETE) відображаються на конкретні методи в контролерах, забезпечуючи правильну обробку запитів. Роути також генерують допоміжні методи для побудови URL-адрес, що полегшує створення посилань у додатку.  [oai_citation_attribution:0‡Ruby on Rails Guides](https://guides.rubyonrails.org/routing.html?utm_source=chatgpt.com)",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "126",
      "title": "Що означає абревіатура CRUD?",
      "body": "**CRUD** — це абревіатура, яка позначає чотири основні операції для роботи з даними: **C**reate (створення), **R**ead (читання), **U**pdate (оновлення) та **D**elete (видалення). Ці операції є фундаментальними для більшості додатків, які взаємодіють з базами даних.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "127",
      "title": "Якщо потрібно зробити новий CRUD для певного ресурсу, які класи ви створите та які файли зміните?",
      "body": "Щоб реалізувати повний набір операцій CRUD для нового ресурсу в Rails, слід виконати наступні кроки:\n 1. **Створити модель**: Це клас, який відповідає за взаємодію з відповідною таблицею в базі даних.\n 2. **Створити контролер**: Цей клас обробляє HTTP-запити та викликає відповідні методи моделі.\n 3. **Налаштувати маршрути**: В файлі `config/routes.rb` слід визначити маршрути, які будуть відповідати на запити та викликати відповідні дії контролера.\n 4. **Створити представлення**: Це файли в папці `app/views`, які відповідають за відображення даних користувачу.\n Ці кроки забезпечують повну реалізацію CRUD-операцій для нового ресурсу.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "128",
      "title": "Що таке ресурси?",
      "body": "У Rails, **ресурси** — це абстракція, яка спрощує створення маршрутизації для стандартних операцій CRUD. Використовуючи `resources :назва_ресурсу`, Rails автоматично генерує всі необхідні маршрути та допоміжні методи для роботи з цим ресурсом.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "129",
      "title": "Що таке Singular ресурси і що відрізняє їх від звичайних ресурсів?",
      "body": "**Singular ресурси** використовуються для представлення одиничних ресурсів, які не мають колекції. Вони визначаються за допомогою `resource :назва_ресурсу` в маршрутах. На відміну від звичайних (plural) ресурсів, які мають колекцію об'єктів, singular ресурси зазвичай відповідають за обробку окремих екземплярів, наприклад, профілю користувача.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "130",
      "title": "Що роблять неймспейси в роутах?",
      "body": "**Неймспейси** в роутах дозволяють організовувати контролери в окремі простори імен, що допомагає структурувати великий додаток. Використовуючи `namespace :namespace_name do ... end` у файлі `config/routes.rb`, ви можете групувати маршрути та відповідні контролери під певним простором імен.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "131",
      "title": "Що таке вкладені ресурси?",
      "body": "**Вкладені ресурси** дозволяють відображати відносини між моделями, наприклад, коли один ресурс належить до іншого. В маршрутах це реалізується через вкладеність, що відображає такі відносини. Наприклад, якщо у вас є `Article` і `Comment`, де коментарі належать до статті, ви можете визначити вкладені ресурси таким чином:\n```ruby\n resources :articles do\n resources :comments\n end\n```\n Це створить маршрути, які враховують цю вкладеність.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "132",
      "title": "Що таке shallow nesting?",
      "body": "**Shallow nesting** — це підхід до визначення вкладених ресурсів, при якому маршрути для ресурсів на глибших рівнях визначаються окремо від батьківських ресурсів. Це спрощує маршрутизацію та покращує читабельність коду. У Rails це реалізується за допомогою опції `shallow: true` при визначенні вкладених ресурсів. Наприклад:\n ```ruby\n resources :articles do\n resources :comments, shallow: true\n end\n ```\n У цьому випадку, маршрути для `comments` будуть визначені окремо від `articles`, що спрощує їх використання.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "133",
      "title": "Що означає RESTful роути?",
      "body": "**RESTful роути** відповідають принципам архітектури REST (Representational State Transfer), які визначають стандартизований спосіб взаємодії з ресурсами через HTTP. У Rails, використання RESTful роути забезпечує відповідність цим принципам, де кожен маршрут відповідає конкретній дії над ресурсом, що робить додаток більш структурованим та зрозумілим.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "134",
      "title": "Що таке нересурсні роути?",
      "body": "**Нересурсні роути** в Ruby on Rails — це маршрути, які не відповідають стандартній RESTful-конвенції, тобто не відображаються на стандартні CRUD-операції для ресурсів. Вони використовуються для реалізації нестандартних дій або маршрутів, які не вписуються в загальну структуру ресурсів. Наприклад, для обробки спеціальних запитів або виконання дій, які не відповідають CRUD-операціям, можна визначити окремі маршрути поза контекстом ресурсів.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "135",
      "title": "Що таке actions в роутах?",
      "body": "**Actions** в роутах Ruby on Rails — це методи в контролерах, які відповідають на конкретні HTTP-запити. Кожна дія (action) обробляє певний тип запиту для відповідного ресурсу. Наприклад, метод `index` може обробляти запити GET до списку ресурсів, а метод `show` — запити GET для перегляду окремого ресурсу. Визначаючи дії в контролерах, розробники вказують, як додаток повинен реагувати на різні запити користувачів.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "136",
      "title": "Що таке view і для чого він потрібен?",
      "body": "**View** (представлення) в Ruby on Rails відповідає за відображення даних користувачу. Воно поєднує HTML з вбудованим Ruby-кодом (ERB), що дозволяє динамічно генерувати веб-сторінки на основі даних, отриманих від контролера.  [oai_citation_attribution:0‡Ruby on Rails Guides](https://guides.rubyonrails.org/action_view_overview.html?utm_source=chatgpt.com)",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "137",
      "title": "Що таке layout? Чим відрізняється від view?",
      "body": "**Layout** (макет) в Ruby on Rails — це шаблон, який обгортає ваші представлення, забезпечуючи єдину структуру для всіх сторінок, включаючи заголовки, футери та інші спільні елементи. На відміну від окремих представлень, які відповідають за відображення конкретних даних, макети визначають загальний вигляд та структуру сторінки.  [oai_citation_attribution:1‡GeeksforGeeks](https://www.geeksforgeeks.org/layouts-in-ruby-on-rails/?utm_source=chatgpt.com)",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "138",
      "title": "Що таке шаблонізатор і з якими шаблонізаторами доводилося працювати?",
      "body": "**Шаблонізатор** — це інструмент, який дозволяє поєднувати код з шаблонами для динамічного генерування HTML-сторінок. У Ruby on Rails за замовчуванням використовується Embedded Ruby (ERB), але також підтримуються інші шаблонізатори, такі як Haml та Slim, які пропонують різний синтаксис та можливості для розробників.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "139",
      "title": "Навіщо потрібен метод render? Що можна рендерити за його допомогою?",
      "body": "Метод **render** в Ruby on Rails використовується для відображення частин представлень, таких як шаблони, часткові види (partials) або інші формати, як JSON чи XML. Це дозволяє гнучко управляти тим, які дані та в якому форматі відправляються клієнту.  [oai_citation_attribution:2‡Ruby on Rails Guides](https://guides.rubyonrails.org/layouts_and_rendering.html?utm_source=chatgpt.com)",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "140",
      "title": "Як передаються змінні у view?",
      "body": "Змінні передаються у представлення через екземплярні змінні контролера (починаються з `@`). Ці змінні доступні як у контролері, так і в відповідних представленнях, що дозволяє передавати дані від контролера до виду для відображення.  [oai_citation_attribution:3‡TutorialsPoint](https://www.tutorialspoint.com/ruby-on-rails/rails-views.htm?utm_source=chatgpt.com)",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "141",
      "title": "Що таке partial? Коли варто його застосовувати?",
      "body": "**Partial** (частковий вид) — це фрагмент представлення, який можна повторно використовувати в інших представленнях. Вони допомагають уникнути дублювання коду та роблять представлення більш організованими. Застосовувати partial доцільно, коли є спільні елементи або блоки, які повторюються на кількох сторінках.  [oai_citation_attribution:4‡Ruby on Rails Guides](https://guides.rubyonrails.org/layouts_and_rendering.html?utm_source=chatgpt.com)",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "142",
      "title": "Що таке хелпер і навіщо його використовують?",
      "body": "**Хелпер** — це модуль, який містить методи для спрощення та повторного використання коду у представленнях. Вони забезпечують чистоту та читабельність представлень, делегуючи складну логіку до хелперів. Наприклад, хелпери можуть включати методи для форматування дат, чисел або створення посилань.  [oai_citation_attribution:5‡Ruby on Rails Guides](https://guides.rubyonrails.org/v5.0/action_view_overview.html?utm_source=chatgpt.com)",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "143",
      "title": "Які є хелпери для генерації роутів?",
      "body": "Rails надає хелпери для генерації роутів, які відповідають за створення URL-адрес для різних дій та ресурсів. Наприклад, `new_article_path` генерує шлях до сторінки створення нової статті, а `article_path(@article)` — до сторінки перегляду конкретної статті. Ці хелпери спрощують роботу з маршрутами та забезпечують їхню консистентність.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "144",
      "title": "Які є хелпери для генерації форм?",
      "body": "Rails пропонує хелпери для генерації форм, які спрощують створення HTML-форм з урахуванням безпеки та зручності. Методи, такі як `form_for` або `form_with`, автоматично генерують відповідні теги форми, поля вводу та інші елементи, прив'язуючи їх до моделей та забезпечуючи валідацію та обробку даних.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "145",
      "title": "Як створювати власні хелпери?",
      "body": "Власні хелпери створюються шляхом визначення методів у модулях, які потім підключаються до представлень. Ці методи можуть виконувати різні допоміжні функції, такі як форматування тексту, обчислення значень або генерація HTML-елементів. Створення власних хелперів покращує організацію коду та сприяє повторному використанню логіки.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "146",
      "title": "Що таке ActionMailer і які завдання він розв'язує?",
      "body": "**ActionMailer** — це компонент фреймворку Ruby on Rails, який дозволяє надсилати електронні листи безпосередньо з вашого додатка. Він надає можливість створювати класи (мейлери) та відповідні представлення для формування та налаштування електронних листів. Мейлери є класами, які успадковуються від `ActionMailer::Base` і схожі за структурою на контролери.\n\n**Завдання, які розв'язує ActionMailer:**\n\n- Формування та надсилання електронних листів з додатка.\n- Налаштування різних способів доставки листів (SMTP, Sendmail тощо).\n- Підтримка текстових та HTML-форматів листів.\n- Обробка вкладень та вбудованих зображень.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "147",
      "title": "Що таке AssetsPipeline і які завдання він виконує?",
      "body": "**Asset Pipeline** — це механізм у Ruby on Rails, призначений для організації, обробки та обслуговування статичних ресурсів, таких як JavaScript, CSS та зображення. Він забезпечує структуру для конкатенації та мініфікації або стиснення JavaScript та CSS файлів, а також додає можливість писати ці ресурси іншими мовами та препроцесорами, такими як CoffeeScript, Sass та ERB.\n\n**Завдання, які виконує Asset Pipeline:**\n\n- Об'єднання та стиснення файлів JavaScript та CSS для зменшення кількості HTTP-запитів та обсягу переданих даних.\n- Підтримка препроцесорів, що дозволяє писати CSS та JavaScript з використанням розширених можливостей.\n- Автоматичне включення ресурсів з гемів та інших бібліотек.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "148",
      "title": "Які є консольні команди для роботи з RoR? Що таке rake-таски?",
      "body": "**Консольні команди для роботи з Ruby on Rails:**\n\n- `rails new myapp` — створює новий Rails-додаток.\n- `rails server` або `rails s` — запускає вбудований веб-сервер.\n- `rails console` або `rails c` — відкриває інтерактивну консоль Rails.\n- `rails generate` або `rails g` — генерує різні компоненти додатка (моделі, контролери, міграції тощо).\n- `rails db:migrate` — застосовує міграції бази даних.\n- `rails routes` — відображає список доступних маршрутів у додатку.\n\n**Rake-таски** — це завдання, визначені за допомогою утиліти Rake, яка є Ruby-еквівалентом Make. Вони використовуються для автоматизації різних завдань, таких як міграції баз даних, очищення тимчасових файлів або завантаження даних. У Rails багато стандартних завдань вже визначено, але ви також можете створювати власні для специфічних потреб вашого додатка.\n\n**Приклади Rake-тасок:**\n\n- `rake db:migrate` — застосовує міграції бази даних.\n- `rake db:seed` — заповнює базу даних початковими даними.\n- `rake assets:precompile` — компілює статичні ресурси для продакшн-середовища.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "149",
      "title": "Чи знаєте якісь вразливі місця, захист від яких Rails надає out of the box?",
      "body": "Ruby on Rails забезпечує вбудований захист від кількох поширених веб-уразливостей:\n\n- **SQL-ін'єкції**: Rails автоматично екранує параметри запитів до бази даних, запобігаючи виконанню шкідливого коду.\n- **XSS (Cross-Site Scripting)**: Вбудовані механізми екранування в представленнях захищають від впровадження шкідливого JavaScript-коду.\n- **CSRF (Cross-Site Request Forgery)**: Rails генерує та перевіряє токени автентифікації для захисту від несанкціонованих запитів від імені користувача.",
      "category": "Security",
      "rank": "Junior"
    },
    {
      "id": "150",
      "title": "Які атаки можуть бути при неправильному використанні сесій? Чому не можна зберігати важливі дані в сесіях?",
      "body": "Неправильне використання сесій може призвести до таких атак:\n\n- **Викрадення сесії (Session Hijacking)**: Зловмисник може отримати доступ до сесійного ідентифікатора та діяти від імені користувача.\n- **Фіксація сесії (Session Fixation)**: Нападник нав'язує жертві відомий йому сесійний ідентифікатор, щоб пізніше використати його.\n\nЗберігання важливих даних у сесіях небезпечне, оскільки сесії можуть бути перехоплені або викрадені, що призведе до компрометації конфіденційної інформації.",
      "category": "Security",
      "rank": "Junior"
    },
    {
      "id": "151",
      "title": "Що таке CSRF? Як правильно захиститися від CSRF?",
      "body": "**CSRF (Cross-Site Request Forgery)** — це атака, при якій зловмисник змушує користувача виконати небажані дії на веб-додатку, в якому той автентифікований. Для захисту від CSRF Rails використовує токени автентифікації, які додаються до форм та перевіряються при обробці запитів.",
      "category": "Security",
      "rank": "Junior"
    },
    {
      "id": "152",
      "title": "У чому вразливість Open Redirect? Як захиститися від можливих атак, пов'язаних з Open Redirect?",
      "body": "**Open Redirect** — це вразливість, коли веб-додаток перенаправляє користувача на зовнішній URL без належної перевірки. Це може бути використано для фішингу або інших шахрайських дій. Для захисту слід обмежити перенаправлення лише на довірені URL або ретельно перевіряти параметри перенаправлення.",
      "category": "Security",
      "rank": "Junior"
    },
    {
      "id": "153",
      "title": "Які вразливості пов'язані із завантаженням файлів? Чому важливо фільтрувати імена та розширення файлів? Як захиститися від небезпеки?",
      "body": "Вразливості, пов'язані із завантаженням файлів, включають:\n\n- **Завантаження шкідливих файлів**: Зловмисник може завантажити файл зі шкідливим кодом, який може бути виконаний на сервері.\n- **Переповнення сховища**: Масове завантаження великих файлів може призвести до вичерпання дискового простору.\n\nФільтрація імен та розширень файлів важлива для запобігання завантаженню небезпечних файлів. Рекомендується обмежувати дозволені типи файлів, перевіряти розширення та вміст файлів, а також зберігати їх у безпечних каталогах, недоступних для виконання.",
      "category": "Security",
      "rank": "Junior"
    },
    {
      "id": "154",
      "title": "Чому не можна завантажувати файли в каталог, доступний зовні? Що буде, якщо зловмисник завантажить файл із кодом?",
      "body": "Завантаження файлів у каталоги, доступні ззовні, небезпечне, оскільки зловмисник може завантажити файл зі шкідливим кодом та виконати його, отримавши контроль над сервером. Тому слід зберігати завантажені файли в недоступних для виконання каталогах та ретельно перевіряти їх вміст.",
      "category": "Security",
      "rank": "Junior"
    },
    {
      "id": "155",
      "title": "Які вразливості пов'язані з управлінням користувачами (посилання активації, паролі в чистому вигляді)? Як захиститись?",
      "body": "Вразливості в управлінні користувачами включають:\n\n- **Небезпечні посилання активації**: Якщо посилання активації не мають обмеженого терміну дії або недостатньо захищені, зловмисник може їх використати.\n- **Зберігання паролів у відкритому вигляді**: Це призводить до компрометації всіх облікових записів у разі витоку даних.\n\nДля захисту слід використовувати безпечні токени з обмеженим терміном дії для активації та зберігати паролі лише в хешованому вигляді з використанням надійних алгоритмів.",
      "category": "Security",
      "rank": "Junior"
    },
    {
      "id": "156",
      "title": "Що таке ін’єкції та як відбувається така атака? Як їх уникнути?",
      "body": "**Ін’єкції** — це тип атак, при яких зловмисник вводить шкідливий код у програму через вхідні дані, що призводить до небажаних дій, таких як виконання небезпечних команд або доступ до конфіденційної інформації. Найпоширеніші види ін’єкцій:\n\n- **SQL-ін’єкції**: атака, при якій зловмисник вставляє шкідливі SQL-запити через вхідні дані, що може призвести до несанкціонованого доступу або модифікації бази даних.\n- **XSS (Cross-Site Scripting)**: впровадження шкідливого скрипта на веб-сторінку, який виконується в браузері користувача, що може призвести до викрадення даних або виконання небажаних дій від імені користувача.\n\nДля запобігання ін’єкціям слід:\n\n- **Екранувати вхідні дані**: перевіряти та очищати всі дані, що надходять від користувача, перед їх використанням у запитах або відображенні на сторінці.\n- **Використовувати підготовлені запити**: застосовувати параметризовані запити для взаємодії з базою даних, що запобігає впровадженню шкідливого коду.\n- **Використовувати механізми захисту фреймворків**: багато сучасних фреймворків, таких як Ruby on Rails, мають вбудовані засоби захисту від ін’єкцій, які слід правильно налаштовувати та використовувати.",
      "category": "Security",
      "rank": "Junior"
    },
    {
      "id": "157",
      "title": "Як організувати безпечну генерацію запрошень? Що таке deep_munge?",
      "body": "**Безпечна генерація запрошень** у веб-додатках передбачає створення унікальних, непередбачуваних та захищених токенів для запрошень користувачів. Це можна досягти за допомогою:\n\n- **Використання криптографічно стійких генераторів випадкових чисел**: наприклад, метод `SecureRandom.hex` у Ruby, який генерує випадковий рядок.\n- **Встановлення терміну дії запрошення**: обмеження часу, протягом якого запрошення є дійсним, зменшує ризик його зловживання.\n- **Зберігання хешованих токенів**: замість зберігання токенів у відкритому вигляді, їх слід хешувати перед збереженням у базі даних.\n\n**`deep_munge`** — це метод у Ruby on Rails, який обробляє параметри запитів, видаляючи порожні масиви та хеші з параметрів. Це робиться для запобігання потенційним уразливостям, пов'язаним із неочікуваною генерацією SQL-запитів із умовами `IS NULL`.  [oai_citation_attribution:0‡Ruby on Rails Guides](https://guides.rubyonrails.org/security.html?utm_source=chatgpt.com)",
      "category": "Security",
      "rank": "Junior"
    },
    {
      "id": "158",
      "title": "Де розташовується основна конфігурація програми?",
      "body": "Основна конфігурація програми в Ruby on Rails розташовується в каталозі `config/`. У цьому каталозі знаходяться файли, які відповідають за налаштування різних аспектів додатка, такі як `application.rb`, `database.yml`, `routes.rb` та інші.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "159",
      "title": "Що таке initializers? Навіщо вони?",
      "body": "**Initializers** — це файли в каталозі `config/initializers/`, які використовуються для ініціалізації налаштувань або поведінки додатка під час його завантаження. Вони дозволяють встановлювати конфігурації для сторонніх бібліотек, налаштовувати глобальні змінні або визначати поведінку додатка до початку його роботи.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "160",
      "title": "Що таке оточення? Яке його призначення?",
      "body": "**Оточення** (environment) в Ruby on Rails визначає режим роботи додатка, наприклад, `development`, `test` або `production`. Кожне оточення має власні налаштування, що дозволяє адаптувати поведінку додатка відповідно до потреб розробки, тестування або реальної експлуатації.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "161",
      "title": "Як і де налаштовується взаємодія з базою даних?",
      "body": "Взаємодія з базою даних налаштовується у файлі `config/database.yml`. У цьому файлі вказуються параметри підключення до бази даних для кожного оточення, такі як адаптер, ім'я бази даних, користувач, пароль та хост.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "162",
      "title": "Як і де налаштовується Assets, генератори, мідлвари, i18n?",
      "body": "Налаштування для **Assets**, генераторів, мідлварів та i18n здійснюються у файлі `config/application.rb` або у відповідних файлах в каталозі `config/initializers/`. Тут можна визначити шляхи до ресурсів, налаштувати генератори scaffold, додати або видалити мідлвари та встановити параметри локалізації.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "163",
      "title": "Чи можна вказувати довільні налаштування? Якщо так, то де і яким чином?",
      "body": "Так, у Ruby on Rails можна вказувати довільні налаштування. Це можна зробити, створивши власні файли конфігурації в каталозі `config/` або додавши налаштування у файли initializers. Також можна використовувати `Rails.application.config` для встановлення кастомних параметрів.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "164",
      "title": "Що таке кеш і навіщо потрібен цей механізм?",
      "body": "**Кеш** — це тимчасове сховище даних, яке використовується для швидкого доступу до часто запитуваної інформації. Механізм кешування дозволяє зменшити навантаження на сервер та прискорити роботу додатка, зберігаючи результати обчислень або запитів для повторного використання.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "165",
      "title": "Які види кешування є в Rails?",
      "body": "У Ruby on Rails існують такі види кешування:\n\n- **Кешування сторінок**: зберігає повний вміст сторінки для швидкої видачі без повторної обробки запиту.\n- **Кешування дій (екшенів)**: зберігає результати виконання окремих дій контролера.\n- **Кешування фрагментів**: зберігає окремі частини представлення (view), що дозволяє оновлювати лише змінені фрагменти без перегенерації всієї сторінки.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "166",
      "title": "Де може зберігатися кеш?",
      "body": "Кеш може зберігатися в різних місцях, залежно від налаштувань додатка:\n\n- **У пам'яті сервера**: швидкий доступ, але обмежений обсягом оперативної пам'яті.\n- **У файловій системі**: зберігання кешованих даних у файлах на диску.\n- **У зовнішніх сервісах**: використання спеціалізованих систем кешування, таких як Memcached або Redis, для зберігання кешу.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "167",
      "title": "Навіщо використовувати кешування сторінок?",
      "body": "Кешування сторінок дозволяє зберігати повний вміст сторінки після першого запиту, що забезпечує швидку відповідь на наступні запити без повторної обробки контролера та генерації представлення. Це значно знижує навантаження на сервер та покращує швидкість відгуку додатка.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "168",
      "title": "Навіщо використовувати кешування екшенів?",
      "body": "Кешування екшенів зберігає результати виконання окремих дій контролера. Це корисно, коли певні дії потребують тривалого часу для виконання або використовують ресурсоємні операції. Завдяки кешуванню екшенів, наступні запити до цих дій можуть оброблятися швидше, оскільки результат вже збережений.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "169",
      "title": "Навіщо використовувати кешування фрагментів?",
      "body": "Кешування фрагментів дозволяє зберігати окремі частини представлення (view), такі як partials або окремі блоки HTML-коду. Це корисно, коли лише частина сторінки змінюється часто, а інші частини залишаються статичними. Кешування фрагментів допомагає уникнути перегенерації всієї сторінки, що покращує продуктивність додатка.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "170",
      "title": "Що таке Memcached?",
      "body": "**Memcached** — це високопродуктивна система кешування, яка зберігає дані та об'єкти в оперативній пам'яті для прискорення доступу до них. Вона використовується для зменшення навантаження на базу даних та підвищення швидкості роботи веб-додатків, забезпечуючи швидкий доступ до часто запитуваної інформації.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "171",
      "title": "Навіщо і як реалізується низькорівневе кешування?",
      "body": "Низькорівневе кешування використовується для зберігання даних на рівні окремих об'єктів або запитів, що дозволяє контролювати процес кешування більш детально. У Rails це реалізується за допомогою методів кешування, які дозволяють зберігати та отримувати дані з кешу вручну, забезпечуючи гнучкість та контроль над процесом кешування.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "172",
      "title": "Як і коли кешується SQL?",
      "body": "У Rails кешування SQL-запитів відбувається автоматично під час виконання однакових запитів у межах одного циклу запиту-відповіді. Це означає, що якщо один і той самий запит виконується кілька разів протягом одного запиту HTTP, результат буде взятий з кешу, що зменшує кількість звернень до бази даних та покращує продуктивність.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "173",
      "title": "Як тестувати кешування в режимі розробки?",
      "body": "У режимі розробки кешування зазвичай вимкнено для спрощення процесу налагодження. Однак, для тестування кешування в цьому режимі, можна тимчасово увімкнути його в конфігураційних файлах або використовувати спеціальні інструменти та методи, які дозволяють перевіряти роботу кешу без переходу в режим продакшн.",
      "category": "Ruby on Rails",
      "rank": "Junior"
    },
    {
      "id": "174",
      "title": "Що таке СУБД?",
      "body": "**Система управління базами даних (СУБД)** — це програмне забезпечення, яке забезпечує створення, управління та взаємодію з базами даних. Вона дозволяє користувачам зберігати, змінювати та отримувати дані, забезпечуючи цілісність, безпеку та доступність інформації.",
      "category": "Relational databases",
      "rank": "Junior"
    },
    {
      "id": "175",
      "title": "Що таке реляційна база даних?",
      "body": "**Реляційна база даних** — це тип бази даних, в якій дані організовані у вигляді таблиць (відношень), де кожна таблиця складається з рядків (записів) та стовпців (полів). Така структура дозволяє встановлювати зв'язки між даними в різних таблицях, забезпечуючи ефективне зберігання та обробку інформації.",
      "category": "Relational databases",
      "rank": "Junior"
    },
    {
      "id": "176",
      "title": "Що таке нормалізація бази даних?",
      "body": "**Нормалізація бази даних** — це процес організації структури бази даних з метою мінімізації надлишковості даних та уникнення аномалій при їх оновленні, вставці або видаленні. Нормалізація передбачає розбиття великих таблиць на менші та встановлення між ними зв'язків.",
      "category": "Relational databases",
      "rank": "Junior"
    },
    {
      "id": "177",
      "title": "Що таке нормальна форма?",
      "body": "**Нормальна форма** — це набір правил або умов, яких повинна дотримуватися база даних для забезпечення її оптимальної структури. Кожна наступна нормальна форма накладає додаткові обмеження, спрямовані на покращення структури даних та зменшення надлишковості.",
      "category": "Relational databases",
      "rank": "Junior"
    },
    {
      "id": "178",
      "title": "Скільки є нормальних форм баз даних?",
      "body": "Існує кілька нормальних форм баз даних, серед яких найпоширенішими є перші три: **перша нормальна форма (1НФ)**, **друга нормальна форма (2НФ)** та **третя нормальна форма (3НФ)**. Також існують **Бойс-Кодда нормальна форма (BCNF)**, **четверта нормальна форма (4НФ)** та **п'ята нормальна форма (5НФ)**.",
      "category": "Relational databases",
      "rank": "Junior"
    },
    {
      "id": "179",
      "title": "Опишіть перші три нормальні форми баз даних.",
      "body": "1. **Перша нормальна форма (1НФ)**: таблиця перебуває в 1НФ, якщо всі її атрибути містять лише атомарні (неподільні) значення, а кожен запис є унікальним.\n2. **Друга нормальна форма (2НФ)**: таблиця перебуває в 2НФ, якщо вона вже в 1НФ і всі неключові атрибути повністю залежать від первинного ключа, тобто немає часткових залежностей.\n3. **Третя нормальна форма (3НФ)**: таблиця перебуває в 3НФ, якщо вона вже в 2НФ і жоден неключовий атрибут не залежить транзитивно від первинного ключа, тобто немає залежностей між неключовими атрибутами.",
      "category": "Relational databases",
      "rank": "Junior"
    },
    {
      "id": "180",
      "title": "Що таке денормалізація баз даних?",
      "body": "**Денормалізація баз даних** — це процес об'єднання таблиць або додавання надлишкових даних з метою покращення продуктивності запитів. Хоча денормалізація може призвести до дублювання даних, вона іноді використовується для зменшення кількості об'єднань (JOIN) та прискорення доступу до інформації.",
      "category": "Relational databases",
      "rank": "Junior"
    },
    {
      "id": "181",
      "title": "У чому різниця між Primary Key та Foreign Key? Навіщо вони?",
      "body": "**Primary Key (первинний ключ)** — це унікальний ідентифікатор запису в таблиці, який гарантує унікальність кожного рядка. **Foreign Key (зовнішній ключ)** — це атрибут або набір атрибутів у таблиці, який посилається на первинний ключ іншої таблиці, встановлюючи зв'язок між таблицями. Використання первинних та зовнішніх ключів забезпечує цілісність даних та визначає відносини між таблицями.",
      "category": "Relational databases",
      "rank": "Junior"
    },
    {
      "id": "182",
      "title": "Яка різниця між LEFT JOIN, INNER JOIN, RIGHT JOIN?",
      "body": "1. **INNER JOIN**: повертає лише ті рядки, де є відповідність в обох таблицях.\n2. **LEFT JOIN**: повертає всі рядки з лівої таблиці та відповідні рядки з правої таблиці. Якщо відповідності немає, то в результаті будуть NULL значення для правої таблиці.\n3. **RIGHT JOIN**: повертає всі рядки з правої таблиці та відповідні рядки з лівої таблиці. Якщо відповідності немає, то в результаті будуть NULL значення для лівої таблиці.",
      "category": "Relational databases",
      "rank": "Junior"
    },
    {
      "id": "183",
      "title": "Як додати запис у таблицю без ORM?",
      "body": "Щоб додати запис у таблицю без використання ORM, можна виконати SQL-запит **INSERT INTO**. Наприклад:\n```sql\nINSERT INTO table_name (column1, column2, column3) VALUES (value1, value2, value3);\n```",
      "category": "Relational databases",
      "rank": "Junior"
    },
    {
      "id": "184",
      "title": "Як оновити запис у таблиці без ORM?",
      "body": "Щоб оновити запис у таблиці без використання ORM, можна виконати SQL-запит **UPDATE**. Наприклад:\n```sql\nUPDATE table_name\nSET column1 = value1, column2 = value2\nWHERE condition;\n```\nЦей запит оновлює значення вказаних колонок для рядків, які відповідають умові в операторі **WHERE**.",
      "category": "Relational databases",
      "rank": "Junior"
    },
    {
      "id": "185",
      "title": "Як видалити запис з таблиці без ORM?",
      "body": "Щоб видалити запис з таблиці без використання ORM, можна виконати SQL-запит **DELETE**. Наприклад:\n```sql\nDELETE FROM table_name\nWHERE condition;\n```\nЦей запит видаляє рядки з таблиці, які відповідають умові в операторі **WHERE**. Якщо умову не вказано, будуть видалені всі записи з таблиці.",
      "category": "Relational databases",
      "rank": "Junior"
    },
    {
      "id": "186",
      "title": "Як прочитати записи в таблиці без ORM?",
      "body": "Щоб прочитати записи з таблиці без використання ORM, можна виконати SQL-запит **SELECT**. Наприклад:\n```sql\nSELECT column1, column2\nFROM table_name\nWHERE condition;\n```\nЦей запит вибирає вказані колонки з таблиці для рядків, які відповідають умові в операторі **WHERE**. Якщо потрібно вибрати всі колонки, можна використовувати символ зірочки (*):\n```sql\nSELECT *\nFROM table_name;\n```",
      "category": "Relational databases",
      "rank": "Junior"
    },
    {
      "id": "187",
      "title": "Які правила групування даних у таблиці ви знаєте?",
      "body": "Групування даних у таблиці здійснюється для узагальнення та аналізу інформації. Основні правила групування включають:\n\n1. **Вибір групувальної ознаки**: визначення атрибута, за яким будуть об'єднуватися дані. Це можуть бути якісні (категорійні) або кількісні показники.\n\n2. **Поділ на інтервали**: для кількісних даних часто використовують поділ на інтервали (діапазони значень), щоб спростити аналіз.\n\n3. **Комбінаційне групування**: одночасне групування за кількома ознаками для детальнішого аналізу взаємозв'язків між ними.\n\n4. **Використання агрегатних функцій**: застосування функцій, таких як SUM, AVG, COUNT, для обчислення підсумкових показників у кожній групі.\n\n5. **Упорядкування груп**: сортування груп за зростанням або спаданням значень групувальної ознаки для покращення сприйняття даних.\n\nДотримання цих правил дозволяє ефективно організувати та аналізувати дані в таблицях.",
      "category": "Relational databases",
      "rank": "Junior"
    },
    {
      "id": "188",
      "title": "Що таке DML (Data Manipulation Language)?",
      "body": "DML (Мова маніпулювання даними) — це набір команд у SQL, які використовуються для роботи з даними в базі даних. Вони дозволяють додавати, змінювати, видаляти та отримувати дані з таблиць. Основні команди DML: SELECT — вибірка даних; INSERT — додавання даних; UPDATE — оновлення даних; DELETE — видалення даних.",
      "category": "SQL",
      "rank": "Junior"
    },
    {
      "id": "189",
      "title": "Що таке DDL (Data Definition Language)?",
      "body": "DDL (Мова визначення даних) — це набір команд у SQL, які використовуються для визначення або зміни структури об’єктів бази даних, таких як таблиці, схеми чи індекси. Основні команди DDL: CREATE — створення об’єкта (наприклад, таблиці); ALTER — зміна структури об’єкта; DROP — видалення об’єкта; TRUNCATE — видалення всіх даних із таблиці без видалення її структури.",
      "category": "SQL",
      "rank": "Junior"
    },
    {
      "id": "190",
      "title": "Що таке DCL (Data Control Language)?",
      "body": "DCL (Мова керування даними) — це набір команд у SQL, які використовуються для керування правами доступу до об’єктів бази даних. Основні команди DCL: GRANT — надання прав доступу; REVOKE — скасування прав доступу.",
      "category": "SQL",
      "rank": "Junior"
    },
    {
      "id": "191",
      "title": "Що таке TCL (Transaction Control Language)?",
      "body": "TCL (Мова керування транзакціями) — це набір команд у SQL, які використовуються для керування транзакціями в базі даних. Транзакція — це послідовність операцій, яка виконується як єдине ціле. Основні команди TCL: COMMIT — збереження змін транзакції; ROLLBACK — відміна змін транзакції; SAVEPOINT — встановлення точки збереження в транзакції; SET TRANSACTION — налаштування параметрів транзакції.",
      "category": "SQL",
      "rank": "Junior"
    },
    {
      "id": "192",
      "title": "Як вибрати дані з кількох таблиць? Які види JOIN ви знаєте?",
      "body": "Щоб вибрати дані з кількох таблиць, використовується оператор JOIN у SQL. Він дозволяє об’єднувати записи з різних таблиць на основі спільного ключа (зазвичай первинного та зовнішнього). Види JOIN: INNER JOIN — повертає лише збіги між таблицями; LEFT (OUTER) JOIN — повертає всі записи з лівої таблиці та збіги з правої (якщо збігів немає, повертається NULL); RIGHT (OUTER) JOIN — повертає всі записи з правої таблиці та збіги з лівої; FULL (OUTER) JOIN — повертає всі записи з обох таблиць, заповнюючи NULL там, де немає збігів; CROSS JOIN — повертає декартовий добуток (усі можливі комбінації записів).",
      "category": "SQL",
      "rank": "Junior"
    },
    {
      "id": "193",
      "title": "Які агреговані показники можна використовувати під час вибірки з таблиці?",
      "body": "Агреговані функції в SQL дозволяють виконувати обчислення на наборі даних. Основні агреговані показники: COUNT — підрахунок кількості записів; SUM — сума значень; AVG — середнє значення; MIN — мінімальне значення; MAX — максимальне значення. Їх часто використовують із GROUP BY для групування даних.",
      "category": "SQL",
      "rank": "Junior"
    },
    {
      "id": "194",
      "title": "Що таке таблиця у базі даних?",
      "body": "Таблиця в базі даних — це структурований набір даних, організований у вигляді рядків і стовпців. Кожен стовпець має назву та тип даних (наприклад, INTEGER, VARCHAR), а кожен рядок представляє окремий запис. Таблиці пов’язані між собою за допомогою ключів (первинних і зовнішніх) у реляційних базах даних.",
      "category": "SQL",
      "rank": "Junior"
    },
    {
      "id": "195",
      "title": "Як створити таблицю?",
      "body": "Щоб створити таблицю, використовується команда CREATE TABLE. Приклад: CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(50), age INT); Тут id — первинний ключ, name — текстове поле, age — числове поле.",
      "category": "SQL",
      "rank": "Junior"
    },
    {
      "id": "196",
      "title": "Як вибрати записи з таблиці?",
      "body": "Для вибірки записів із таблиці використовується команда SELECT. Приклад: SELECT * FROM users; — вибирає всі записи з таблиці users. Можна вказати умови: SELECT name, age FROM users WHERE age > 18; — вибирає імена та вік користувачів старше 18 років.",
      "category": "SQL",
      "rank": "Junior"
    },
    {
      "id": "197",
      "title": "Як вставити запис у таблицю?",
      "body": "Для вставки запису використовується команда INSERT. Приклад: INSERT INTO users (id, name, age) VALUES (1, 'Олег', 25); — додає новий запис у таблицю users.",
      "category": "SQL",
      "rank": "Junior"
    },
    {
      "id": "198",
      "title": "Як змінити запис у таблиці?",
      "body": "Для зміни запису використовується команда UPDATE. Приклад: UPDATE users SET age = 26 WHERE id = 1; — змінює вік користувача з id=1 на 26.",
      "category": "SQL",
      "rank": "Junior"
    },
    {
      "id": "199",
      "title": "Як видалити запис із таблиці?",
      "body": "Для видалення запису використовується команда DELETE. Приклад: DELETE FROM users WHERE id = 1; — видаляє запис із таблиці users, де id=1.",
      "category": "SQL",
      "rank": "Junior"
    },
    {
      "id": "200",
      "title": "Як об’єднати вибірку з різних таблиць?",
      "body": "Для об’єднання вибірки з різних таблиць використовується JOIN. Приклад: SELECT users.name, orders.order_date FROM users INNER JOIN orders ON users.id = orders.user_id; — об’єднує таблиці users і orders за ключем user_id і вибирає ім’я та дату замовлення.",
      "category": "SQL",
      "rank": "Junior"
    },
    {
      "id": "201",
      "title": "Що таке групування або агрегування?",
      "body": "Групування (агрегування) — це процес об’єднання записів у групи за певною ознакою з використанням агрегованих функцій. У SQL це робиться за допомогою GROUP BY. Приклад: SELECT age, COUNT(*) FROM users GROUP BY age; — підраховує кількість користувачів для кожного віку.",
      "category": "SQL",
      "rank": "Junior"
    },
    {
      "id": "202",
      "title": "Яким чином можна задавати умови агрегування?",
      "body": "Умови агрегування задаються за допомогою HAVING, яке застосовується після GROUP BY. Приклад: SELECT age, COUNT(*) FROM users GROUP BY age HAVING COUNT(*) > 2; — вибирає вікові групи, де більше двох користувачів. WHERE використовується для фільтрації до групування, а HAVING — після.",
      "category": "SQL",
      "rank": "Junior"
    },
    {
      "id": "203",
      "title": "Що таке індекси в базі даних?",
      "body": "Індекси в базі даних — це спеціальні структури даних, які створюються для прискорення пошуку та доступу до даних у таблицях. Вони працюють подібно до змісту в книзі, дозволяючи базі даних швидко знаходити рядки без необхідності сканувати всю таблицю.",
      "category": "SQL indexes",
      "rank": "Junior"
    },
    {
      "id": "204",
      "title": "Для чого потрібні індекси?",
      "body": "Індекси потрібні для підвищення продуктивності запитів, таких як SELECT, WHERE, JOIN тощо. Вони зменшують час виконання запитів, дозволяючи базі даних ефективніше знаходити потрібні дані, але можуть уповільнювати операції вставки, оновлення чи видалення через необхідність оновлення індексу.",
      "category": "SQL indexes",
      "rank": "Junior"
    },
    {
      "id": "205",
      "title": "Які види індексів існують?",
      "body": "Існують різні види індексів: 1) B-деревні (B-Tree) — найпоширеніші, для загального використання; 2) Хеш-індекси — для точних збігів; 3) Бітові (Bitmap) — для стовпців із низькою кардинальністю; 4) Повнотекстові — для пошуку по тексту; 5) Унікальні — для забезпечення унікальності значень; 6) Складові — на кількох стовпцях.",
      "category": "SQL indexes",
      "rank": "Junior"
    },
    {
      "id": "206",
      "title": "Що таке первинний ключ?",
      "body": "Первинний ключ (Primary Key) — це унікальний ідентифікатор кожного рядка в таблиці. Він не може містити NULL і дубльованих значень, забезпечуючи унікальність записів. Зазвичай використовується для зв’язку між таблицями.",
      "category": "SQL indexes",
      "rank": "Junior"
    },
    {
      "id": "207",
      "title": "Що таке зовнішній ключ?",
      "body": "Зовнішній ключ (Foreign Key) — це стовпець або набір стовпців у одній таблиці, який посилається на первинний ключ іншої таблиці. Він забезпечує зв’язок між таблицями та підтримує цілісність даних.",
      "category": "SQL indexes",
      "rank": "Junior"
    },
    {
      "id": "208",
      "title": "Що таке складовий ключ?",
      "body": "Складовий ключ (Composite Key) — це ключ, який складається з двох або більше стовпців, що разом утворюють унікальний ідентифікатор для рядка. Використовується, коли один стовпець не може гарантувати унікальність.",
      "category": "SQL indexes",
      "rank": "Junior"
    },
    {
      "id": "209",
      "title": "Що таке повнотекстовий пошук і в чому його завдання?",
      "body": "Повнотекстовий пошук — це метод пошуку, який дозволяє знаходити записи в базі даних за вмістом текстових даних, а не лише за точними збігами. Його завдання — ефективно обробляти запити з природної мови, наприклад, пошук слів чи фраз у великих обсягах тексту.",
      "category": "SQL indexes",
      "rank": "Junior"
    },
    {
      "id": "210",
      "title": "Що таке повнотекстовий індекс?",
      "body": "Повнотекстовий індекс — це спеціальний тип індексу, який створюється для прискорення повнотекстового пошуку. Він індексує слова або фрази в текстових стовпцях, дозволяючи швидко знаходити збіги за ключовими словами чи виразами.",
      "category": "SQL indexes",
      "rank": "Junior"
    },
    {
      "id": "211",
      "title": "Що таке ts_vector?",
      "body": "ts_vector — це тип даних у PostgreSQL, який представляє текстовий документ у вигляді структури, зручної для повнотекстового пошуку. Він містить список слів (лексем) із їх позиціями в тексті, що дозволяє ефективно виконувати пошукові запити.",
      "category": "SQL indexes",
      "rank": "Junior"
    },
    {
      "id": "212",
      "title": "Що таке ts_query?",
      "body": "ts_query — це тип даних у PostgreSQL, який представляє пошуковий запит для повнотекстового пошуку. Він містить слова або фрази, які потрібно знайти, разом із логічними операторами (AND, OR, NOT), і використовується разом із ts_vector для виконання пошуку.",
      "category": "SQL indexes",
      "rank": "Junior"
    },
    {
      "id": "213",
      "title": "Що таке SELECT DISTINCT і яка його функція?",
      "body": "SELECT DISTINCT — це оператор у SQL, який використовується для вибірки унікальних значень із стовпця або набору стовпців, усуваючи дублікати. Його функція — повернути лише різні (неповторювані) рядки з результатів запиту.",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "214",
      "title": "Яким чином можна сортувати результати вибірки?",
      "body": "Результати вибірки сортуються за допомогою оператора ORDER BY. Наприклад, `SELECT column FROM table ORDER BY column ASC` (за зростанням) або `DESC` (за спаданням). Можна сортувати за кількома стовпцями, вказавши їх через кому.",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "215",
      "title": "Як обмежити кількість результатів вибірки?",
      "body": "Для обмеження кількості результатів використовується оператор LIMIT. Наприклад, `SELECT column FROM table LIMIT 10` поверне перші 10 рядків. Також можна комбінувати з OFFSET для пропуску рядків, наприклад, `LIMIT 10 OFFSET 5`.",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "216",
      "title": "Як проводити пошук за підрядками?",
      "body": "Пошук за підрядками у PostgreSQL виконується за допомогою оператора LIKE (`WHERE column LIKE '%abc%'`) або ILIKE (нечутливий до регістру). Також можна використовувати функцію `strpos` або регулярні вирази (`~` або `~*` для нечутливого до регістру).",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "217",
      "title": "Які види об’єднань (JOIN) є в PostgreSQL?",
      "body": "У PostgreSQL є такі види JOIN: 1) INNER JOIN — повертає лише збіги; 2) LEFT OUTER JOIN — усі рядки з лівої таблиці; 3) RIGHT OUTER JOIN — усі рядки з правої таблиці; 4) FULL OUTER JOIN — усі рядки з обох таблиць; 5) CROSS JOIN — декартовий добуток.",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "218",
      "title": "Що таке підзапити і в чому їхнє завдання?",
      "body": "Підзапити — це запити, вкладені в основний запит (наприклад, у WHERE чи FROM). Їхнє завдання — розбити складні задачі на менші частини, отримувати проміжні результати або фільтрувати дані на основі умов із іншої таблиці.",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "219",
      "title": "Які типи даних є в PostgreSQL?",
      "body": "У PostgreSQL є числові (integer, numeric), символьні (char, varchar, text), логічні (boolean), дата/час (date, time, timestamp), JSON (json, jsonb), масиви, геометричні типи, UUID, enum тощо.",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "220",
      "title": "Які є види символьних типів даних?",
      "body": "Символьні типи в PostgreSQL: 1) CHAR(n) — фіксована довжина з доповненням пробілами; 2) VARCHAR(n) — змінна довжина з обмеженням; 3) TEXT — змінна довжина без обмеження.",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "221",
      "title": "Які є види типів даних для роботи з датою та часом?",
      "body": "Типи даних для дати та часу: 1) DATE — лише дата; 2) TIME — лише час; 3) TIMESTAMP — дата і час; 4) TIMESTAMPTZ — дата і час із часовим поясом; 5) INTERVAL — проміжок часу.",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "222",
      "title": "Що таке тип enum? Коли він використовується?",
      "body": "Тип ENUM — це перелічуваний тип даних, який дозволяє задавати список допустимих значень. Використовується, коли стовпець має обмежений набір фіксованих значень, наприклад, статуси ('active', 'inactive').",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "223",
      "title": "Як можна створювати таблиці у базі даних?",
      "body": "Таблиці створюються за допомогою оператора CREATE TABLE. Наприклад: `CREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR(50));`. Можна додавати обмеження, індекси тощо.",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "224",
      "title": "Як змінювати структуру таблиці?",
      "body": "Структуру таблиці змінюють за допомогою ALTER TABLE. Наприклад: додати стовпець — `ALTER TABLE users ADD COLUMN age INT;`, змінити тип — `ALTER TABLE users ALTER COLUMN name TYPE VARCHAR(100);`, видалити стовпець — `ALTER TABLE users DROP COLUMN age;`.",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "225",
      "title": "Як видаляти таблиці?",
      "body": "Таблиці видаляють за допомогою DROP TABLE. Наприклад: `DROP TABLE users;` видалить таблицю. Додатковий параметр `CASCADE` видаляє залежності.",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "226",
      "title": "Як очистити таблицю?",
      "body": "Для очищення таблиці використовується TRUNCATE. Наприклад: `TRUNCATE TABLE users;` видаляє всі рядки, але зберігає структуру. Параметр `RESTART IDENTITY` скидає лічильники.",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "227",
      "title": "Чи можливо задавати значення за замовчуванням для полів? Якщо так, то як саме?",
      "body": "Так, це можливо за допомогою DEFAULT. Наприклад: `CREATE TABLE users (id SERIAL, status VARCHAR DEFAULT 'active');`. Значення застосовується, якщо при вставці не вказано інше.",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "228",
      "title": "Чи можливо контролювати унікальність значень під час вставлення? Якщо так, то яким чином?",
      "body": "Так, унікальність контролюється через обмеження UNIQUE або PRIMARY KEY. Наприклад: `CREATE TABLE users (email VARCHAR UNIQUE);`. При вставці дубля система видасть помилку.",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "229",
      "title": "Що таке функції в PostgreSQL?",
      "body": "Функції в PostgreSQL — це збережені процедури, які виконують певні обчислення чи логіку. Вони можуть бути написані на SQL, PL/pgSQL тощо. Наприклад: `CREATE FUNCTION add(a INT, b INT) RETURNS INT AS $$ SELECT a + b; $$ LANGUAGE SQL;`.",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "230",
      "title": "Які оператори є в PostgreSQL?",
      "body": "У PostgreSQL є арифметичні (+, -, *, /), порівняння (=, <, >, !=), логічні (AND, OR, NOT), оператори роботи з рядками (||, LIKE), бітові (&, |), а також спеціальні, як `IS NULL` чи `BETWEEN`.",
      "category": "PostgreSQL",
      "rank": "Junior"
    },
    {
      "id": "231",
      "title": "Що це таке Redis і навіщо використовують цей інструмент?",
      "body": "Redis — це відкрита, високопродуктивна система зберігання даних у пам'яті (in-memory data store), яка використовується як база даних, кеш і брокер повідомлень. Вона підтримує різні структури даних, такі як рядки, списки, множини, хеші та відсортовані множини. Redis використовують для швидкого доступу до даних у реальному часі, наприклад, для кешування, управління сесіями, черг повідомлень, аналітики в реальному часі та лідербордів у іграх, завдяки його швидкості та низькій затримці.",
      "category": "NoSQL",
      "rank": "Junior"
    },
    {
      "id": "232",
      "title": "Що таке Elasticsearch і навіщо його використовують?",
      "body": "Elasticsearch — це розподілений пошуковий і аналітичний двигун із відкритим кодом, побудований на основі Apache Lucene. Він призначений для зберігання, індексації та швидкого пошуку великих обсягів структурованих і неструктурованих даних у реальному часі. Elasticsearch використовують для повнотекстового пошуку, аналізу логів, моніторингу додатків, бізнес-аналітики та систем оповіщення, завдяки його можливостям швидкого пошуку, агрегації та масштабованості.",
      "category": "NoSQL",
      "rank": "Junior"
    },
    {
      "id": "233",
      "title": "Що таке Overcommit і навіщо потрібен?",
      "body": "Overcommit — це інструмент для Ruby-проєктів, який дозволяє налаштовувати та запускати git hooks (хуки) для автоматизації перевірок перед комітом коду. Він потрібен для забезпечення якості коду, автоматичного запуску статичних аналізаторів, тестів або форматування, щоб уникнути внесення помилок у репозиторій.",
      "category": "Static code analysis",
      "rank": "Junior"
    },
    {
      "id": "234",
      "title": "Що таке Danger і для чого використовується?",
      "body": "Danger — це інструмент автоматизації перевірки коду, який інтегрується з системами CI/CD (наприклад, GitHub Actions). Він аналізує pull requests, коментарі до коду, запускає правила (написані на Ruby чи JavaScript) і залишає відгуки розробникам. Використовується для автоматизації код-рев’ю, забезпечення відповідності стандартам і зменшення ручної роботи.",
      "category": "Static code analysis",
      "rank": "Junior"
    },
    {
      "id": "235",
      "title": "Що таке статичні аналізатори коду? Навіщо їх використовують?",
      "body": "Статичні аналізатори коду — це інструменти, які перевіряють вихідний код без його виконання, шукаючи помилки, потенційні баги, порушення стилю чи безпеки. Їх використовують для підвищення якості коду, зменшення кількості помилок, забезпечення відповідності стандартам і полегшення підтримки проєктів.",
      "category": "Static code analysis",
      "rank": "Junior"
    },
    {
      "id": "236",
      "title": "Які аналізатори для Ruby / Ruby on Rails знаєте?",
      "body": "Для Ruby та Ruby on Rails популярні аналізатори: 1) RuboCop — для перевірки стилю та якості коду; 2) Reek — для виявлення 'code smells'; 3) Brakeman — для аналізу безпеки Rails-додатків; 4) Rails Best Practices — для рекомендацій щодо архітектури Rails; 5) Fasterer — для оптимізації продуктивності.",
      "category": "Static code analysis",
      "rank": "Junior"
    },
    {
      "id": "237",
      "title": "Які статичні аналізатори коду для JavaScript знаєте?",
      "body": "Для JavaScript популярні аналізатори: 1) ESLint — для пошуку помилок і забезпечення стилю; 2) JSHint — для виявлення потенційних проблем; 3) Prettier — для форматування (часто з ESLint); 4) SonarJS — для глибшого аналізу якості; 5) Flow — для статичної типізації.",
      "category": "Static code analysis",
      "rank": "Junior"
    },
    {
      "id": "238",
      "title": "Які види тестування знаєте? Які з них ви практикували під час використання Rails?",
      "body": "Види тестування: юніт-тестування (unit), інтеграційне, функціональне, приймальне, регресійне, навантажувальне, безпекове тощо. У Rails часто практикують юніт-тестування (моделі, сервіси), інтеграційне (контролери, API), функціональне (запити) та приймальне (з Capybara для UI).",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "239",
      "title": "Який фреймворк для тестування використовуєте?",
      "body": "У Rails часто використовую RSpec як основний фреймворк для тестування завдяки його зрозумілому синтаксису та гнучкості. Іноді Minitest — стандартний інструмент Rails.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "240",
      "title": "Які показники якості для своїх тестів можете назвати?",
      "body": "Показники якості тестів: покриття коду (code coverage), швидкість виконання, читабельність, незалежність тестів, стабільність (відсутність 'flaky tests'), релевантність (тестування ключових функцій).",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "241",
      "title": "За допомогою якої бібліотеки контролюєте процент покриття тестами?",
      "body": "Для контролю покриття тестами використовую SimpleCov — гем для Ruby, який інтегрується з RSpec або Minitest і показує відсоток покриття коду у звіті.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "242",
      "title": "Розкажіть про основи тестування в Ruby? Що таке RSpec? Яка різниця між describe, context та it?",
      "body": "Тестування в Ruby базується на перевірці поведінки коду. RSpec — це DSL для написання читабельних тестів. `describe` групує тести за класом чи методом, `context` описує конкретний сценарій, `it` визначає окремий тест-кейс із очікуванням.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "243",
      "title": "Які різниця між юніт-тестами та інтеграційними?",
      "body": "Юніт-тести перевіряють окремі компоненти (наприклад, методи) ізольовано, а інтеграційні — взаємодію кількох компонентів (наприклад, контролер і модель) у реальних умовах.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "244",
      "title": "Що перевіряють приймальним тестуванням?",
      "body": "Приймальне тестування перевіряє, чи відповідає система вимогам користувача, імітуючи реальні сценарії використання (наприклад, взаємодію з UI або API).",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "245",
      "title": "Що перевіряють інтеграційним тестуванням?",
      "body": "Інтеграційне тестування перевіряє коректну взаємодію між модулями системи, наприклад, чи правильно контролер обробляє дані з моделі.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "246",
      "title": "Що тестують у моделях?",
      "body": "У моделях тестують валідації, асоціації, методи бізнес-логіки та поведінку при збереженні чи оновленні записів.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "247",
      "title": "Що тестують у контролерах?",
      "body": "У контролерах тестують маршрутизацію, обробку параметрів, HTTP-статуси, рендеринг шаблонів або повернення JSON.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "248",
      "title": "Що тестують у серіалайзерах?",
      "body": "У серіалайзерах тестують правильність форматування даних (наприклад, JSON), включення чи виключення полів, коректність вкладених об’єктів.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "249",
      "title": "Як тестувати API?",
      "body": "API тестують через інтеграційні тести: відправляють запити (GET, POST тощо) за допомогою бібліотек типу Rack::Test чи Capybara, перевіряють статус відповіді, структуру JSON і поведінку ендпоінтів.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "250",
      "title": "Як тестувати різні Service Objects?",
      "body": "Service Objects тестують як юніт-тести: створюють екземпляр, передають вхідні дані, перевіряють результат роботи методу та побічні ефекти (наприклад, зміни в БД).",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "251",
      "title": "Що таке RSpec? Які завдання виконує цей інструмент?",
      "body": "RSpec — це фреймворк для поведінкового тестування (BDD) у Ruby. Він дозволяє писати тести у стилі специфікацій, перевіряючи поведінку коду через `describe`, `context`, `it`. Завдання: автоматизація тестування, підтримка читабельності.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "252",
      "title": "У чому різниця між let і let! у RSpec?",
      "body": "`let` створює ліниву змінну (обчислюється при виклику), `let!` — примусово ініціалізує змінну перед кожним тестом, навіть якщо вона не використовується.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "253",
      "title": "Які хуки в RSpec знаєте?",
      "body": "Хуки в RSpec: `before(:each)` — перед кожним тестом, `before(:all)` — перед усіма тестами в групі, `after(:each)`, `after(:all)` — після тестів, `around` — обгортка навколо тесту.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "254",
      "title": "Що виконується раніше let! чи хук before(:all)?",
      "body": "`before(:all)` виконується раніше, ніж `let!`, оскільки хуки рівня `:all` запускаються перед усією групою тестів, а `let!` — перед кожним тестом окремо.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "255",
      "title": "Що таке Capybara? Які завдання вирішує Capybara?",
      "body": "Capybara — бібліотека для інтеграційного тестування вебдодатків. Вона імітує дії користувача (кліки, заповнення форм) і перевіряє UI. Завдання: тестування поведінки сторінок.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "256",
      "title": "Що таке стаби?",
      "body": "Стаби (stubs) — це замінники реальних об’єктів чи методів із фіксованими відповідями, щоб ізолювати код під час тестування.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "257",
      "title": "Що таке моки?",
      "body": "Моки (mocks) — це об’єкти, які не лише замінюють реальні, а й перевіряють, чи були викликані певні методи з очікуваними аргументами.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "258",
      "title": "Що таке матчер?",
      "body": "Матчер (matcher) у RSpec — це метод для перевірки очікувань у тестах, наприклад, `expect(result).to eq(5)` або `expect(object).to be_present`.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "259",
      "title": "Яке завдання виконує гем Shoulda Matchers?",
      "body": "Shoulda Matchers — це гем, який спрощує тестування Rails-моделей, надаючи зручні матчери для валідацій, асоціацій тощо (наприклад, `should validate_presence_of(:name)`).",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "260",
      "title": "Яке завдання виконує Faker?",
      "body": "Faker — це гем для генерації випадкових тестових даних (імена, email тощо), щоб заповнювати БД або створювати фікстури для тестів.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "261",
      "title": "Навіщо потрібні Webmock і VCR? Чим вони відрізняються?",
      "body": "Webmock блокує реальні HTTP-запити й повертає стаби, VCR записує реальні запити та відтворює їх. Webmock — для ізоляції, VCR — для повторного використання відповідей.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "262",
      "title": "Що таке WebKit і PhantomJS? У чому різниця між ними? Які ще є драйвери?",
      "body": "WebKit — движок браузера, PhantomJS — безголовий браузер на WebKit. Різниця: PhantomJS — повноцінний інструмент, WebKit — лише основа. Інші драйвери: Selenium, Chrome Headless, Poltergeist.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "263",
      "title": "Як працювати з базою даних у тестах? Як працює gem database_cleaner?",
      "body": "У тестах БД очищають між запусками. DatabaseCleaner підтримує стратегії: `transaction` (швидка для юніт-тестів), `truncation` (повне очищення), `deletion`. Налаштовується для RSpec чи Minitest.",
      "category": "Testing",
      "rank": "Junior"
    },
    {
      "id": "264",
      "title": "Що таке SSH? Як і для чого використовується?",
      "body": "SSH (Secure Shell) — це протокол для безпечного віддаленого доступу до систем через мережу. Використовується для входу на сервери, виконання команд, передачі файлів (наприклад, через SCP або SFTP). Основне призначення — безпечне адміністрування серверів і обмін даними з шифруванням.",
      "category": "DevOps",
      "rank": "Junior"
    },
    {
      "id": "265",
      "title": "Яким чином можна налаштувати аутентифікацію на хості без пароля?",
      "body": "Для аутентифікації без пароля через SSH використовують ключову пару: генерують приватний і публічний ключі командою `ssh-keygen`, копіюють публічний ключ на хост за допомогою `ssh-copy-id user@host`. На сервері ключ додається до `~/.ssh/authorized_keys`, після чого пароль не потрібен.",
      "category": "DevOps",
      "rank": "Junior"
    },
    {
      "id": "266",
      "title": "Які завдання виконує Heroku? У чому його особливість?",
      "body": "Heroku — це PaaS-платформа для розгортання, масштабування та управління додатками. Завдання: спрощення деплою, автоматичне масштабування, інтеграція з Git. Особливість — абстракція від інфраструктури (серверів), фокус на розробці та легкість використання.",
      "category": "DevOps",
      "rank": "Junior"
    },
    {
      "id": "267",
      "title": "Які завдання виконує DigitalOcean?",
      "body": "DigitalOcean — це хмарний провайдер (IaaS), який надає віртуальні сервери (Droplets) для розгортання додатків. Завдання: хостинг, створення серверів, управління інфраструктурою. Популярний завдяки простоті, доступності та підтримці DevOps-інструментів.",
      "category": "DevOps",
      "rank": "Junior"
    },
    {
      "id": "268",
      "title": "Які завдання виконує Docker?",
      "body": "Docker — це платформа для контейнеризації додатків. Завдання: упаковка додатків із залежностями в контейнери, забезпечення однакового середовища на різних етапах (розробка, тестування, продакшн), спрощення деплою та масштабування.",
      "category": "DevOps",
      "rank": "Junior"
    },
    {
      "id": "269",
      "title": "Які завдання виконують Airbrake, DataDog, NewRelic?",
      "body": "Airbrake — відстежує помилки в додатках, групує їх і сповіщає розробників для швидкого виправлення. DataDog — забезпечує моніторинг інфраструктури, додатків і логів у реальному часі, об’єднуючи метрики, трасування й аналітику. NewRelic — пропонує комплексний моніторинг продуктивності додатків (APM), інфраструктури та досвіду користувачів із детальною аналітикою.",
      "category": "Monitoring",
      "rank": "Junior"
    },
    {
      "id": "270",
      "title": "З якою метою використовують Monit?",
      "body": "Monit — це утиліта для моніторингу та управління процесами, файлами, директоріями та системними ресурсами на сервері. Використовується для автоматичного перезапуску сервісів при збоях, відстеження стану системи та сповіщення адміністраторів про проблеми.",
      "category": "Monitoring",
      "rank": "Junior"
    },
    {
      "id": "271",
      "title": "Які є вебсервери, написані на Ruby?",
      "body": "Вебсервери, написані на Ruby: 1) Puma — популярний багатопоточний сервер для Rails; 2) Unicorn — сервер із підтримкою багатопроцесорності; 3) Thin — легкий сервер із підтримкою асинхронності; 4) WEBrick — стандартний сервер Ruby (простий, для розробки).",
      "category": "Web tools Ruby",
      "rank": "Junior"
    },
    {
      "id": "272",
      "title": "Що таке Sinatra?",
      "body": "Sinatra — це легкий вебфреймворк на Ruby для створення простих вебдодатків і API. Він мінімалістичний, на відміну від Rails, і дозволяє швидко налаштувати маршрути та обробку запитів із мінімальним кодом.",
      "category": "Web tools Ruby",
      "rank": "Junior"
    },
    {
      "id": "273",
      "title": "Що таке API? Для чого використовується? Що таке серіалайзери і навіщо вони потрібні?",
      "body": "API (Application Programming Interface) — це інтерфейс для взаємодії між програмами, який дозволяє обмінюватися даними (наприклад, через HTTP). Використовується для інтеграції сервісів. Серіалайзери — інструменти для перетворення даних (наприклад, об’єктів Ruby) у формати типу JSON. Вони потрібні для стандартизації та спрощення передачі даних.",
      "category": "Web tools Ruby",
      "rank": "Junior"
    },
    {
      "id": "274",
      "title": "Що таке клієнт-серверна модель?",
      "body": "Клієнт-серверна модель — це архітектура, де клієнт (наприклад, браузер) надсилає запити до сервера, а сервер обробляє їх і повертає відповідь. Клієнт ініціює зв’язок, сервер надає ресурси чи послуги.",
      "category": "Web tools Ruby",
      "rank": "Junior"
    },
    {
      "id": "275",
      "title": "Яка різниця між GET- та POST-запитами?",
      "body": "GET-запити використовуються для отримання даних із сервера, видимі в URL, обмежені за розміром. POST-запити — для надсилання даних на сервер (наприклад, форм), передаються в тілі запиту, безпечніші та не обмежені за обсягом.",
      "category": "Web tools Ruby",
      "rank": "Junior"
    },
    {
      "id": "276",
      "title": "Що таке HTTParty і які завдання він виконує?",
      "body": "HTTParty — це Ruby-бібліотека для роботи з HTTP-запитами. Завдання: спрощення надсилання GET, POST тощо, обробка відповідей (JSON, XML), інтеграція з API. Легка у використанні для простих запитів.",
      "category": "Web tools Ruby",
      "rank": "Junior"
    },
    {
      "id": "277",
      "title": "Що таке Faraday і які завдання він виконує?",
      "body": "Faraday — це гнучка Ruby-бібліотека для HTTP-запитів із підтримкою адаптерів (Net::HTTP, Typhoeus). Завдання: виконання запитів, обробка відповідей, налаштування middleware для логування, аутентифікації тощо.",
      "category": "Web tools Ruby",
      "rank": "Junior"
    },
    {
      "id": "278",
      "title": "Що таке Rack? Що таке Rack-application? Що таке Rack middleware?",
      "body": "Rack — це інтерфейс у Ruby для взаємодії вебсерверів із додатками. Rack-application — додаток, який відповідає на запити за специфікацією Rack (метод `call`). Rack middleware — проміжний шар між сервером і додатком для обробки запитів/відповідей (наприклад, логування, аутентифікація).",
      "category": "Web tools Ruby",
      "rank": "Junior"
    },
    {
      "id": "279",
      "title": "Що таке push-технологія?",
      "body": "Push-технологія — це метод, коли сервер主动 надсилає дані клієнту без його запиту (наприклад, WebSockets, Server-Sent Events). Використовується для оновлень у реальному часі (чати, сповіщення).",
      "category": "Web tools Ruby",
      "rank": "Junior"
    },
    {
      "id": "280",
      "title": "Що таке SOLID? Наведіть приклади на кожну з літер.",
      "body": "SOLID — це набір принципів ООП: S (Single Responsibility) — клас має одну причину для зміни (клас User лише зберігає дані користувача); O (Open/Closed) — розширення без зміни (додавання нового типу знижки через підклас); L (Liskov Substitution) — підкласи замінюють базовий без помилок (Square замість Rectangle); I (Interface Segregation) — інтерфейси специфічні (не змушувати клас реалізувати непотрібне); D (Dependency Inversion) — залежність від абстракцій (сервіс через інтерфейс Logger).",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "281",
      "title": "Що таке мікросервісна архітектура? Які плюси та мінуси ви бачите під час її використання?",
      "body": "Мікросервісна архітектура — це підхід, де додаток розбивається на незалежні сервіси. Плюси: легке масштабування, незалежний деплої, гнучкість технологій. Мінуси: складність координації, накладні витрати на мережу, проблеми з консистентністю даних.",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "282",
      "title": "Чи знаєте ви шаблони проєктування Singleton / Factory / Facade / Decorator / Template Method / Strategy?",
      "body": "Так. Singleton — один екземпляр класу (логер). Factory — створення об’єктів (фабрика для User). Facade — спрощений інтерфейс (API-клієнт). Decorator — розширення поведінки (додавання логування до сервісу). Template Method — алгоритм із кроками (обробка платежів). Strategy — вибір алгоритму (сортування).",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "283",
      "title": "Чи можна виміряти швидкість виконання алгоритму? Які чинники впливають на швидкість? Які види залежностей ви знаєте?",
      "body": "Так, через Big O (O(n), O(log n)). Чинники: обсяг даних, апаратне забезпечення, оптимізація коду. Залежності: O(1) — константна, O(n) — лінійна, O(n²) — квадратична, O(log n) — логарифмічна.",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "284",
      "title": "Що таке методологія Scrum? На яких активностях / зустрічах може бути присутнім / корисним Software Developer?",
      "body": "Scrum — це agile-методологія з ітераціями (спринтами). Розробник бере участь у: Daily Standup (звіт), Sprint Planning (планування), Sprint Review (демо), Retrospective (аналіз).",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "285",
      "title": "Які інструменти для логування використовуєте в роботі?",
      "body": "Використовую: Rails Logger (вбудований), Lograge (структуровані логи), Sidekiq logs (асинхронні задачі), Sentry (для помилок із контекстом).",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "286",
      "title": "Які інструменти для моніторингу вебзастосунків використовуєте?",
      "body": "NewRelic (продуктивність), DataDog (метрики), Airbrake (помилки), Prometheus+Grafana (кастомний моніторинг).",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "287",
      "title": "За допомогою якого / яких інструментів ви деплоїли застосунки на staging / production? Опишіть процес.",
      "body": "Інструменти: Heroku (git push), Capistrano (Ruby-деплой), Docker+CI/CD (GitHub Actions). Процес: код пушиться в репозиторій, CI тестує, деплоїться на сервер через SSH або контейнери.",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "288",
      "title": "Якщо один з ендпоінтів у застосунку відпрацьовує дуже довго, що робити, аби покращити швидкість?",
      "body": "Аналізую запит (EXPLAIN), додаю індекси в БД, кешую (Redis), оптимізую алгоритм, переношу в фон (Sidekiq), зменшую обсяг даних у відповіді.",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "289",
      "title": "Чим відрізняється бібліотека від фреймворку?",
      "body": "Бібліотека — набір функцій, які викликає розробник (HTTParty). Фреймворк — каркас із правилами, який керує потоком (Rails). Бібліотека — інструмент, фреймворк — структура.",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "290",
      "title": "Що таке триланкова архітектура? Навіщо та коли її використовують? Наведіть приклади.",
      "body": "Триланкова архітектура — це поділ на UI (frontend), логіку (backend), дані (БД). Навіщо: модульність, легке масштабування. Приклад: браузер, Rails, PostgreSQL.",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "291",
      "title": "Що таке кешування? Навіщо та коли його використовують? Наведіть приклади.",
      "body": "Кешування — збереження даних для швидкого доступу. Навіщо: прискорення. Коли: при частих запитах. Приклади: Redis для сторінок, браузерний кеш.",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "292",
      "title": "Що таке функціональний розподіл? Навіщо та коли його використовують? Наведіть приклади.",
      "body": "Функціональний розподіл — поділ системи за функціями (авторизація, платежі). Навіщо: чіткість, незалежність. Приклад: окремий сервіс для аутентифікації.",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "293",
      "title": "Що таке Comet-сервер? Навіщо та коли його використовують? Наведіть приклади.",
      "body": "Comet-сервер — технологія для push-повідомлень (long polling). Навіщо: оновлення в реальному часі. Приклад: чат у Rails із ActionCable.",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "294",
      "title": "Що таке денормалізація? Навіщо та коли її використовують? Наведіть приклади.",
      "body": "Денормалізація — додавання дубльованих даних у БД для швидкості. Навіщо: оптимізація читання. Приклад: збереження імені користувача в таблиці замовлень.",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "295",
      "title": "Що таке деградація функціональності? Навіщо вона та в яких випадках використовується? Наведіть приклади.",
      "body": "Деградація — відключення некритичних функцій при навантаженні. Навіщо: стабільність. Приклад: відключення рекомендацій у магазині при піковому трафіку.",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "296",
      "title": "Що таке сервісно-орієнтована архітектура? Навіщо та коли її використовують? Наведіть приклади.",
      "body": "SOA — архітектура з незалежними сервісами, що взаємодіють через API. Навіщо: гнучкість, повторне використання. Приклад: окремий сервіс оплати в ecommerce.",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "297",
      "title": "Що таке монолітний застосунок? Навіщо та коли його використовують? Наведіть приклади.",
      "body": "Моноліт — додаток із єдиною кодовою базою. Навіщо: простота розробки. Приклад: Rails-додаток із UI, логікою та БД в одному.",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "298",
      "title": "Що таке асинхронна обробка? Навіщо та коли її застосовують? Наведіть приклади.",
      "body": "Асинхронна обробка — виконання задач у фоні. Навіщо: швидкість відгуку. Приклад: відправка email через Sidekiq.",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "299",
      "title": "Що таке ліниві обчислення? Навіщо та коли їх використовують? Наведіть приклади.",
      "body": "Ліниві обчислення — відкладене виконання до потреби. Навіщо: економія ресурсів. Приклад: `lazy` у Ruby для масивів.",
      "rank": "Middle",
      "category": "General questions"
    },
    {
      "id": "300",
      "title": "Що таке DDD? У чому переваги перед класичним MVC?",
      "body": "DDD (Domain-Driven Design) — це підхід до проєктування, де фокус на доменній логіці та її відображенні в коді. Переваги перед MVC: краща відповідність складним бізнес-правилам, модульність через поділ контекстів, легше масштабування логіки (MVC фокусується на структурі, а не на домені).",
      "rank": "Middle",
      "category": "Domain-Driven Design"
    },
    {
      "id": "301",
      "title": "Що таке домен?",
      "body": "Домен — це сфера діяльності або бізнес-проблема, яку вирішує додаток. Наприклад, у магазині домен — це процеси замовлень, оплати, доставки.",
      "rank": "Middle",
      "category": "Domain-Driven Design"
    },
    {
      "id": "302",
      "title": "Що таке модель?",
      "body": "Модель — це абстракція домену, представлена в коді, яка відображає ключові концепції та правила бізнесу. Наприклад, клас Order із методами для обчислення вартості.",
      "rank": "Middle",
      "category": "Domain-Driven Design"
    },
    {
      "id": "303",
      "title": "Що таке контекст?",
      "body": "Контекст (Bounded Context) — це межі, в яких модель має чітке значення. Наприклад, 'Product' у контексті каталогу та складського обліку — різні сутності.",
      "rank": "Middle",
      "category": "Domain-Driven Design"
    },
    {
      "id": "304",
      "title": "Що таке сутність?",
      "body": "Сутність (Entity) — це об’єкт із унікальною ідентичністю, який має значення протягом часу. Наприклад, об’єкт User із ID, який змінюється (оновлення імені).",
      "rank": "Middle",
      "category": "Domain-Driven Design"
    },
    {
      "id": "305",
      "title": "Що таке value object?",
      "body": "Value Object — це об’єкт без ідентичності, який визначається своїми атрибутами. Наприклад, Money із сумою та валютою — порівнюється за значеннями, а не ID.",
      "rank": "Middle",
      "category": "Domain-Driven Design"
    },
    {
      "id": "306",
      "title": "Що таке агрегування?",
      "body": "Агрегування (Aggregate) — це сукупність пов’язаних сутностей і value objects, які розглядаються як єдине ціле з коренем (Aggregate Root). Наприклад, Order із OrderItems, де доступ лише через Order.",
      "rank": "Middle",
      "category": "Domain-Driven Design"
    },
    {
      "id": "307",
      "title": "Що роблять команди cherry-pick, log, stash, reset, squash?",
      "body": "`cherry-pick` — переносить конкретний коміт у поточну гілку; `log` — показує історію комітів; `stash` — тимчасово зберігає незакомічені зміни; `reset` — скидає гілку до певного стану (soft/hard); `squash` — об’єднує кілька комітів в один під час rebase.",
      "rank": "Middle",
      "category": "Git"
    },
    {
      "id": "308",
      "title": "Що таке Gitflow? Які правила використання Git на вашому минулому проєкті?",
      "body": "Gitflow — це стратегія роботи з гілками: main (продакшн), develop (інтеграція), feature/* (нові функції), hotfix/* (виправлення). На минулому проєкті: feature-гілки для задач, PR у develop, реліз через тегування, обов’язковий code review.",
      "rank": "Middle",
      "category": "Git"
    },
    {
      "id": "309",
      "title": "Яких правил іменування комітів / гілок / Pull Request’ів ви дотримуєтеся?",
      "body": "Коміти: [тип] опис (наприклад, [feat] Add user auth). Гілки: тип/короткий-опис (feature/user-auth). PR: номер задачі + опис (наприклад, #123 - User auth implementation).",
      "rank": "Middle",
      "category": "Git"
    },
    {
      "id": "310",
      "title": "На що звертаєте увагу під час code review?",
      "body": "Читабельність коду, відповідність стандартам, логіка, покриття тестами, безпека, дублювання коду, продуктивність, коментарі до складних частин.",
      "rank": "Middle",
      "category": "Git"
    },
    {
      "id": "311",
      "title": "Що б ви могли назвати погано проведеним code review?",
      "body": "Погано проведений code review: поверхневий аналіз (лише 'LGTM'), відсутність конструктивних коментарів, ігнорування помилок чи порушення стандартів, затримка без причини.",
      "rank": "Middle",
      "category": "Git"
    },
    {
      "id": "312",
      "title": "Для чого потрібні індекси?",
      "body": "Індекси потрібні для прискорення пошуку та вибірки даних у базі даних, зменшуючи час виконання запитів типу SELECT, WHERE, JOIN, шляхом створення структури для швидкого доступу до рядків.",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "313",
      "title": "Які є види індексів?",
      "body": "Види індексів: B-Tree (універсальний), Hash (для точних збігів), Bitmap (низька кардинальність), GiST і GIN (пошук по масивах, тексту), унікальні (забезпечують унікальність), складові (на кількох полях).",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "314",
      "title": "Чи прискорюють індекси всі операції з базами?",
      "body": "Ні, індекси прискорюють читання (SELECT), але сповільнюють операції запису (INSERT, UPDATE, DELETE), оскільки індекси потрібно оновлювати разом із даними.",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "315",
      "title": "Що таке DB view?",
      "body": "DB view (представлення) — це віртуальна таблиця, створена запитом SELECT, яка не зберігає дані фізично, а відображає їх із базових таблиць у реальному часі.",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "316",
      "title": "Чим відрізняються materialized db view від non-materialized db view?",
      "body": "Materialized view зберігає дані фізично і оновлюється періодично, прискорюючи доступ. Non-materialized view — це лише запит, що виконується щоразу, без зберігання даних.",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "317",
      "title": "Як можна зберегти дані в різні таблиці та гарантувати, що всі вони або запишуться, або ні?",
      "body": "Використовують транзакції: `BEGIN; INSERT INTO table1 ...; INSERT INTO table2 ...; COMMIT;` Якщо щось піде не так, `ROLLBACK;` скасує всі зміни.",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "318",
      "title": "Чи можна будувати індекси за кількома полями? Чи важливий порядок цих полів в індексі?",
      "body": "Так, це складові індекси. Порядок важливий: перше поле частіше використовується в умовах WHERE, а наступні — для додаткової фільтрації чи сортування.",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "319",
      "title": "Які ви знаєте constraints під час створення стовпців?",
      "body": "Constraints: NOT NULL (обов’язкове значення), UNIQUE (унікальність), PRIMARY KEY (унікальний ідентифікатор), FOREIGN KEY (зв’язок із іншою таблицею), DEFAULT (значення за замовчуванням), CHECK (обмеження значень).",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "320",
      "title": "У чому різниця між SQL та NoSQL базами даних?",
      "body": "SQL — реляційні, зі схемою, таблицями (PostgreSQL). NoSQL — гнучкі, без схеми, документи/ключ-значення (MongoDB, Redis). SQL для структурованих даних, NoSQL для неструктурованих і масштабування.",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "321",
      "title": "Як би ви імпортували великі масиви даних у БД (1–2 мільйони рядків у CSV-файл)?",
      "body": "Використовую `COPY` у PostgreSQL для швидкого імпорту з CSV або розбиваю файл на частини й імпортую через bulk insert у транзакціях, щоб уникнути перевантаження.",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "322",
      "title": "Що таке N+1 та як уникати?",
      "body": "N+1 — проблема, коли для вибірки N записів виконується N+1 запитів (1 для списку, N для зв’язків). Уникаю через eager loading (includes/preload у Rails) замість lazy loading.",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "323",
      "title": "Які відмінності між джоінами FULL OUTER JOIN, CROSS JOIN, NATURAL JOIN, INTERSECT та EXPECT?",
      "body": "FULL OUTER JOIN — усі рядки з обох таблиць; CROSS JOIN — декартовий добуток; NATURAL JOIN — об’єднання за однаковими іменами стовпців; INTERSECT — спільні рядки; EXCEPT — рядки, що є в одній таблиці, але не в іншій.",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "324",
      "title": "Які специфічні типи даних є в PostgreSQL?",
      "body": "У PostgreSQL: JSON/JSONB (документи), ARRAY (масиви), UUID (унікальні ідентифікатори), INTERVAL (проміжки часу), GEOMETRY (геодані), HSTORE (ключ-значення).",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "325",
      "title": "Що таке view? З якою метою використовується?",
      "body": "View — це віртуальна таблиця на основі запиту. Використовується для спрощення складних запитів, безпеки (обмеження доступу до даних) і повторного використання логіки.",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "326",
      "title": "Що таке materialized view?",
      "body": "Materialized view — це представлення, яке фізично зберігає дані й оновлюється вручну чи за розкладом. Прискорює доступ до часто використовуваних запитів.",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "327",
      "title": "Що таке recursive view?",
      "body": "Recursive view — це представлення з рекурсивним CTE (WITH RECURSIVE), яке використовується для роботи з ієрархічними даними (наприклад, дерево категорій).",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "328",
      "title": "Що таке збережена процедура і навіщо вона потрібна?",
      "body": "Збережена процедура — це набір SQL-команд, збережених у БД. Потрібна для повторного використання логіки, підвищення продуктивності, централізованого управління кодом.",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "329",
      "title": "Що таке партиціонування та яку проблему воно вирішує?",
      "body": "Партиціонування — це поділ великої таблиці на менші частини (за датою, діапазоном). Вирішує проблему продуктивності при роботі з великими обсягами даних.",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "330",
      "title": "Чи вмієте працювати з чистими SQL-запитами?",
      "body": "Так, пишу запити: SELECT з JOIN, агрегатні функції, підзапити, CTE, індексацію, аналіз через EXPLAIN для оптимізації.",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "331",
      "title": "Яким чином можна працювати з геолокацією в PostgreSQL?",
      "body": "Використовую PostGIS: типи POINT, POLYGON, функції ST_Distance, ST_Within для обчислень відстані чи пошуку в межах зони.",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "332",
      "title": "Які є способи резервного копіювання даних? Що таке pg_dump? У якому вигляді можна створювати резервні копії?",
      "body": "Способи: логічне (pg_dump), фізичне (копії файлів). `pg_dump` — утиліта для створення бекапів у SQL-скриптах чи архівах. Формати: plain (SQL), custom (стиснутий), directory (папка).",
      "rank": "Middle",
      "category": "Databases"
    },
    {
      "id": "333",
      "title": "Що таке Redis? Які завдання він виконує?",
      "body": "Redis — це високопродуктивна in-memory база даних типу ключ-значення з підтримкою різних структур даних. Завдання: кешування, управління сесіями, черги (pub/sub), лідерборди, аналітика в реальному часі.",
      "rank": "Middle",
      "category": "Redis"
    },
    {
      "id": "334",
      "title": "Які типи даних є в Redis і для чого потрібен кожен з них?",
      "body": "Типи даних: 1) String — текст/числа (кеш); 2) List — списки (черги); 3) Set — множини без дублікатів (унікальні елементи); 4) Sorted Set — відсортовані множини (рейтинги); 5) Hash — ключ-значення (об’єкти); 6) Bitmap, HyperLogLog — спеціалізовані (аналітика).",
      "rank": "Middle",
      "category": "Redis"
    },
    {
      "id": "335",
      "title": "Що таке pub / sub?",
      "body": "Pub/Sub (publish/subscribe) — це модель обміну повідомленнями в Redis, де видавець надсилає повідомлення в канал, а підписники отримують їх. Використовується для чатів, сповіщень.",
      "rank": "Middle",
      "category": "Redis"
    },
    {
      "id": "336",
      "title": "Що таке транзакції?",
      "body": "Транзакції в Redis — це набір команд, що виконуються атомарно через `MULTI`/`EXEC`. Гарантують послідовність, але не повну ізоляцію, як у SQL.",
      "rank": "Middle",
      "category": "Redis"
    },
    {
      "id": "337",
      "title": "Що таке mass insertion?",
      "body": "Mass insertion — це масове вставлення даних у Redis, наприклад, через `MSET` для кількох ключів або скрипти/pipe для оптимізації швидкості.",
      "rank": "Middle",
      "category": "Redis"
    },
    {
      "id": "338",
      "title": "Що таке партиціонування?",
      "body": "Партиціонування — це розподіл даних між кількома Redis-інстансами для масштабування. Види: по діапазону ключів, хешування. Вирішує проблему обмеження пам’яті.",
      "rank": "Middle",
      "category": "Redis"
    },
    {
      "id": "339",
      "title": "Чи вмієте працювати з Redis у консолі?",
      "body": "Так, використовую `redis-cli`: `SET key value`, `GET key`, `LPUSH list item`, `SUBSCRIBE channel`, `INFO` для діагностики.",
      "rank": "Middle",
      "category": "Redis"
    },
    {
      "id": "340",
      "title": "Чи вмієте налаштовувати Redis?",
      "body": "Так, редагую `redis.conf`: налаштовую порт, пам’ять (`maxmemory`), політику видалення (`maxmemory-policy`), persistence (RDB/AOF), кластеризацію.",
      "rank": "Middle",
      "category": "Redis"
    },
    {
      "id": "341",
      "title": "Що таке Elasticsearch і які завдання він виконує?",
      "body": "Elasticsearch — це розподілений пошуковий і аналітичний двигун на базі Lucene. Завдання: повнотекстовий пошук, аналіз логів, моніторинг, агрегація даних, зберігання та пошук JSON-документів у реальному часі.",
      "rank": "Middle",
      "category": "Elasticsearch"
    },
    {
      "id": "342",
      "title": "Що таке кластер?",
      "body": "Кластер у Elasticsearch — це сукупність нод, які разом зберігають дані та обробляють запити, забезпечуючи високу доступність і масштабування.",
      "rank": "Middle",
      "category": "Elasticsearch"
    },
    {
      "id": "343",
      "title": "Що таке нода?",
      "body": "Нода — це окремий екземпляр Elasticsearch у кластері, який виконує певну роль (master, data, ingest тощо) і зберігає частину даних або координує роботу.",
      "rank": "Middle",
      "category": "Elasticsearch"
    },
    {
      "id": "344",
      "title": "Що таке індекс?",
      "body": "Індекс — це логічна структура, подібна до таблиці в БД, яка містить документи й дозволяє їх індексувати та шукати. Наприклад, індекс 'users' для документів із даними користувачів.",
      "rank": "Middle",
      "category": "Elasticsearch"
    },
    {
      "id": "345",
      "title": "Що таке тип?",
      "body": "Тип (застаріле з ES 7.x) — це категорія документів в індексі з однаковою структурою. Раніше використовувався для розділення (наприклад, 'post' у блозі), тепер один індекс = один тип.",
      "rank": "Middle",
      "category": "Elasticsearch"
    },
    {
      "id": "346",
      "title": "Що таке документ?",
      "body": "Документ — це базова одиниця даних у Elasticsearch, представлена у форматі JSON. Наприклад, `{ 'name': 'John', 'age': 30 }` — це документ в індексі.",
      "rank": "Middle",
      "category": "Elasticsearch"
    },
    {
      "id": "347",
      "title": "Що таке шарди і репліки?",
      "body": "Шарди (shards) — це частини індексу, розподілені між нодами для масштабування. Репліки — копії шардів для відмовостійкості та паралельного читання.",
      "rank": "Middle",
      "category": "Elasticsearch"
    },
    {
      "id": "348",
      "title": "Що таке Query DSL?",
      "body": "Query DSL — це JSON-подібний синтаксис Elasticsearch для створення запитів. Наприклад, `{'query': {'match': {'title': 'search'}}}` шукає документи зі словом 'search' у полі 'title'.",
      "rank": "Middle",
      "category": "Elasticsearch"
    },
    {
      "id": "349",
      "title": "Що таке мапинг?",
      "body": "Мапинг (mapping) — це схема, яка визначає, як поля документа індексуються та зберігаються (типи даних, аналізатори). Наприклад, `{'properties': {'name': {'type': 'text'}}}`.",
      "rank": "Middle",
      "category": "Elasticsearch"
    },
    {
      "id": "350",
      "title": "Що таке overcommit і навіщо потрібна ця утиліта?",
      "body": "Overcommit — це утиліта для Ruby-проєктів, яка дозволяє налаштовувати та управляти Git-хуками. Вона потрібна для автоматизації перевірок перед комітом чи пушем (наприклад, запуск лінтерів, тестів), щоб забезпечити якість коду та уникнути помилок у репозиторії.",
      "rank": "Middle",
      "category": "Static code analysis"
    },
    {
      "id": "351",
      "title": "Що таке danger і для чого використовують цю утиліту?",
      "body": "Danger — це утиліта для автоматизації code review, яка інтегрується з CI/CD (наприклад, GitHub Actions). Вона аналізує pull requests, перевіряє код за правилами (на Ruby чи JS) і залишає коментарі. Використовується для зменшення ручної роботи та забезпечення стандартів.",
      "rank": "Middle",
      "category": "Static code analysis"
    },
    {
      "id": "352",
      "title": "Які завдання виконує кожен з нижчеперелічених гемів? Rubocop; Reek; Rails Best Practices; Brakeman; RubyCritic; SimpleCov; Bundle Audit; Bundle Leak; Traceroute.",
      "body": "Rubocop — статичний аналізатор для Ruby, перевіряє стиль і якість коду; Reek — шукає 'code smells' у Ruby-коді; Rails Best Practices — аналізує Rails-код на відповідність кращим практикам; Brakeman — виявляє вразливості безпеки в Rails; RubyCritic — оцінює якість коду через Reek, Flay, Flog; SimpleCov — вимірює покриття тестами; Bundle Audit — перевіряє безпеку залежностей у Gemfile.lock; Bundle Leak — виявляє витоки пам’яті через залежності; Traceroute — знаходить невикористані маршрути та дії в Rails.",
      "rank": "Middle",
      "category": "Static code analysis"
    },
    {
      "id": "353",
      "title": "Які завдання виконує кожен з нижчеперелічених модулів? Eslint; Stylelint; Prettier.",
      "body": "Eslint — аналізує JavaScript-код, виявляє помилки та забезпечує стиль; Stylelint — перевіряє CSS/SCSS на відповідність стилю та помилки; Prettier — автоматично форматує код (JS, CSS тощо) для однаковості.",
      "rank": "Middle",
      "category": "Static code analysis"
    },
    {
      "id": "354",
      "title": "Які проблеми в Ruby (як мові програмування) ви бачите, які, на вашу думку, потрібно розв’язувати якнайшвидше?",
      "body": "Проблеми: 1) продуктивність — Ruby повільніший за компільовані мови; 2) GIL (Global Interpreter Lock) обмежує багатопоточність; 3) слабка типізація ускладнює масштабні проєкти. Потрібно: покращити JIT, розширити підтримку типів (RBS), оптимізувати паралелізм.",
      "rank": "Middle",
      "category": "Ruby"
    },
    {
      "id": "355",
      "title": "Якими бібліотеками, окрім фреймворку Rails, користувалися для створення структури проєкту?",
      "body": "Sinatra — для легких API; Dry-rb (dry-struct, dry-validation) — для структур і валідацій; Roda — для маршрутизації; Sidekiq — для фонових задач.",
      "rank": "Middle",
      "category": "Ruby"
    },
    {
      "id": "356",
      "title": "Як можна в Ruby надіслати запит на сторонній API? Який вбудований клас дає змогу це зробити?",
      "body": "Надіслати запит можна через `Net::HTTP` (вбудований клас): `require 'net/http'; uri = URI('http://api.example.com'); response = Net::HTTP.get(uri)`. Також популярні HTTParty, Faraday.",
      "rank": "Middle",
      "category": "Ruby"
    },
    {
      "id": "357",
      "title": "Що таке Thread? Чим він відрізняється від Process?",
      "body": "Thread — потік виконання в межах одного процесу, ділить пам’ять. Process — окремий екземпляр програми з власною пам’яттю. Thread легший, але GIL у Ruby обмежує паралелізм.",
      "rank": "Middle",
      "category": "Ruby"
    },
    {
      "id": "358",
      "title": "Чи є в Ruby можливість створити абстрактний клас? Чи є спосіб штучно створити абстрактний клас?",
      "body": "Прямої підтримки немає, але штучно: модуль або клас із `raise NotImplementedError` у методах, які повинні бути реалізовані в підкласах.",
      "rank": "Middle",
      "category": "Ruby"
    },
    {
      "id": "359",
      "title": "Чи є в Ruby можливість множинного наслідування? Чи є спосіб штучно замінити множинне наслідування?",
      "body": "Ні, Ruby підтримує лише одиночне наслідування. Заміна — через модулі (mixins): `include Module1, Module2` додає поведінку кількох модулів.",
      "rank": "Middle",
      "category": "Ruby"
    },
    {
      "id": "360",
      "title": "Назвіть максимально точний шлях пошуку методів у Ruby?",
      "body": "Пошук: 1) методи об’єкта; 2) модулі, підключені через `include`; 3) клас об’єкта; 4) модулі через `prepend`; 5) батьківський клас (по ланцюжку до BasicObject); 6) `method_missing`.",
      "rank": "Middle",
      "category": "Ruby"
    },
    {
      "id": "361",
      "title": "Які мінуси використання method_missing знаєте?",
      "body": "Мінуси: 1) зниження продуктивності (пошук методу); 2) складність дебагінгу; 3) ризик перехоплення неочікуваних викликів; 4) неявність коду.",
      "rank": "Middle",
      "category": "Ruby"
    },
    {
      "id": "362",
      "title": "Чи можна дізнатись ідентифікатор об’єкта в пам’яті, якщо так, то яким чином?",
      "body": "Так, через метод `object_id` або `__id__`. Наприклад: `obj = 'test'; obj.object_id` повертає унікальний ідентифікатор.",
      "rank": "Middle",
      "category": "Ruby"
    },
    {
      "id": "363",
      "title": "Які види enumerator для масиву ви знаєте?",
      "body": "Для масиву: `each`, `map`, `select`, `reject`, `reduce`, `each_with_index`, `lazy` (лінивий перебір).",
      "rank": "Middle",
      "category": "Ruby"
    },
    {
      "id": "364",
      "title": "Що таке мемоізація методів? Навіщо її використовують?",
      "body": "Мемоізація — кешування результатів методу. Використовують для оптимізації, коли метод повертає однаковий результат для тих самих аргументів. Приклад: `@result ||= heavy_calculation`.",
      "rank": "Middle",
      "category": "Ruby"
    },
    {
      "id": "365",
      "title": "За допомогою якого хука можна порахувати кількість нащадків певного класу?",
      "body": "Через `inherited`: `def self.inherited(subclass); @@subclasses ||= []; @@subclasses << subclass; end` — додає підкласи в масив.",
      "rank": "Middle",
      "category": "Ruby"
    },
    {
      "id": "366",
      "title": "У чому різниця запуску rspec та bundle exec rspec?",
      "body": "`rspec` запускає глобальну версію RSpec, `bundle exec rspec` — версію із Gemfile проєкту, забезпечуючи ізоляцію залежностей.",
      "rank": "Middle",
      "category": "Ruby"
    },
    {
      "id": "367",
      "title": "Чи створювали ви гем у Ruby? Яка механіка / послідовність дій для створення гему?",
      "body": "Так. Механіка: 1) `bundle gem mygem` — створює структуру; 2) редагую gemspec (метадані); 3) пишу код у `lib/mygem.rb`; 4) додаю тести; 5) публікую через `gem build` і `gem push` на RubyGems.",
      "rank": "Middle",
      "category": "Ruby"
    },
    {
      "id": "368",
      "title": "Що таке Rack middleware?",
      "body": "Rack middleware — це проміжний шар між вебсервером і Ruby-додатком, який обробляє запити/відповіді (логування, аутентифікація). Працює через інтерфейс Rack.",
      "rank": "Middle",
      "category": "Ruby"
    },
    {
      "id": "369",
      "title": "Що таке ActiveSupport? Навіщо потрібен? Які завдання виконує? Наведіть приклад методів, які додає ActiveSupport.",
      "body": "ActiveSupport — це бібліотека Rails для розширення Ruby. Навіщо: спрощує роботу з часом, рядками тощо. Завдання: додає утиліти. Приклади: `2.days.ago`, `string.blank?`, `hash.deep_merge`.",
      "rank": "Middle",
      "category": "Ruby on Rails"
    },
    {
      "id": "370",
      "title": "Що таке Action Cable? Навіщо використовують цей фреймворк?",
      "body": "Action Cable — це фреймворк у Rails для WebSocket, що забезпечує оновлення в реальному часі. Використовують для чатів, сповіщень, де потрібен двосторонній зв’язок клієнт-сервер.",
      "rank": "Middle",
      "category": "Ruby on Rails"
    },
    {
      "id": "371",
      "title": "Як створити функціональність для відсилання імейлу в Rails-застосунку?",
      "body": "Створюю mailer: `rails g mailer UserMailer`, додаю метод (наприклад, `welcome_email`), налаштовую SMTP у `config/environment.rb`, викликаю `UserMailer.welcome_email.deliver_later`.",
      "rank": "Middle",
      "category": "Ruby on Rails"
    },
    {
      "id": "372",
      "title": "Які бібліотеки для background jobs використовували? Яка механіка роботи таких бібліотек?",
      "body": "Використовую Sidekiq, Delayed Job. Механіка: задача ставиться в чергу (Redis для Sidekiq), воркер обробляє її асинхронно, результат повертається або зберігається.",
      "rank": "Middle",
      "category": "Ruby on Rails"
    },
    {
      "id": "373",
      "title": "Які види кешу в Rails знаєте? Де можна зберігати кеш?",
      "body": "Види: page caching, action caching, fragment caching, low-level caching. Зберігати: у пам’яті (`ActiveSupport::Cache::MemoryStore`), Redis, Memcached, файлова система.",
      "rank": "Middle",
      "category": "Ruby on Rails"
    },
    {
      "id": "374",
      "title": "Які бібліотеки / підходи для створення API документації знаєте / використовуєте?",
      "body": "Swagger (OpenAPI), RSpec API Doc Generator, Apipie. Підходи: ручне документування у Swagger YAML або автогенерація з тестів.",
      "rank": "Middle",
      "category": "Ruby on Rails"
    },
    {
      "id": "375",
      "title": "Що таке Swagger? Які переваги створення API документації у Swagger-форматі?",
      "body": "Swagger — це інструмент для специфікації API (OpenAPI). Переваги: стандартизація, автогенерація клієнтів, інтерактивний UI для тестування ендпоінтів.",
      "rank": "Middle",
      "category": "Ruby on Rails"
    },
    {
      "id": "376",
      "title": "Що таке Query Objects? Коли і як їх можна використовувати?",
      "body": "Query Objects — класи для інкапсуляції складних SQL-запитів. Коли: для великих запитів у моделях. Як: створюю клас `UsersQuery`, метод `call` повертає результат.",
      "rank": "Middle",
      "category": "Ruby on Rails"
    },
    {
      "id": "377",
      "title": "Що таке Decorators? Коли і як їх можна використовувати?",
      "body": "Decorators — об’єкти для додавання презентаційної логіки до моделей. Коли: для відображення даних (наприклад, форматування). Як: гем Draper, метод `decorate`.",
      "rank": "Middle",
      "category": "Ruby on Rails"
    },
    {
      "id": "378",
      "title": "Що таке Form Objects / Contract? Коли і як їх можна використовувати?",
      "body": "Form Objects/Contracts — класи для обробки форм і валідацій. Коли: складні форми поза моделями. Як: створюю клас `RegistrationForm` із `include ActiveModel::Model`, додаю валідації.",
      "rank": "Middle",
      "category": "Ruby on Rails"
    },
    {
      "id": "379",
      "title": "Де та як ви рекомендуєте тримати бізнес-логіку в Rails-застосунку?",
      "body": "Рекомендую: Service Objects (для операцій), Query Objects (запити), моделі (валидації, асоціації). Не в контролерах чи views, щоб уникнути 'fat controllers'.",
      "rank": "Middle",
      "category": "Ruby on Rails"
    },
    {
      "id": "380",
      "title": "Що таке JSON API формат? Чи використовували бібліотеки для серіалізації об’єктів в JSON API форматі?",
      "body": "JSON API — стандарт для структури API (ресурси, зв’язки). Використовую `jsonapi-serializer` або `active_model_serializers` для серіалізації з підтримкою специфікації.",
      "rank": "Middle",
      "category": "Ruby on Rails"
    },
    {
      "id": "381",
      "title": "Чи працювали ви з feature-тестами? Що таке capybara?",
      "body": "Так, працював із feature-тестами для перевірки UI та інтеграції. Capybara — це бібліотека Ruby для імітації дій користувача (кліки, введення) у браузері, використовується з RSpec для тестування поведінки вебдодатків.",
      "rank": "Middle",
      "category": "Testing"
    },
    {
      "id": "382",
      "title": "Що таке TDD? Які переваги / недоліки використання TDD-підходу бачите?",
      "body": "TDD (Test-Driven Development) — підхід, де спочатку пишуться тести, потім код. Переваги: краща архітектура, менше помилок, документація. Недоліки: час на написання тестів, складність для новачків.",
      "rank": "Middle",
      "category": "Testing"
    },
    {
      "id": "383",
      "title": "Що таке BDD? У чому відмінність між TDD та BDD?",
      "body": "BDD (Behavior-Driven Development) — розвиток TDD, фокус на поведінці системи у термінах бізнесу. Відмінність: TDD тестує технічну реалізацію, BDD — сценарії користувача (наприклад, через Gherkin у Cucumber).",
      "rank": "Middle",
      "category": "Testing"
    },
    {
      "id": "384",
      "title": "Що може бути чинником того, що тести на проєкті виконуються дуже довго?",
      "body": "Чинники: 1) багато інтеграційних тестів із БД; 2) відсутність моків для зовнішніх сервісів; 3) неефективні запити (N+1); 4) повільний CI; 5) надлишкові тести.",
      "rank": "Middle",
      "category": "Testing"
    },
    {
      "id": "385",
      "title": "Що таке принцип тестування FIRST?",
      "body": "FIRST: Fast (швидкі), Independent (незалежні), Repeatable (повторювані), Self-validating (самоперевіряються), Timely (вчасні). Це принципи для створення якісних юніт-тестів.",
      "rank": "Middle",
      "category": "Testing"
    },
    {
      "id": "386",
      "title": "Як порекомендуєте писати тести на код, в якому надсилається запит на сторонній сервіс (API)?",
      "body": "Рекомендую: використовувати моки (Webmock) або стаби (VCR) для ізоляції, тестувати лише логіку коду, а не API, перевіряти вхідні/вихідні дані через `expect(client).to receive(:call).and_return(response)`.",
      "rank": "Middle",
      "category": "Testing"
    },
    {
      "id": "387",
      "title": "Які інструменти допомагають контролювати якість тестів?",
      "body": "SimpleCov (покриття коду), RuboCop-RSpec (стиль тестів), Mutant (мутаційне тестування), RSpec профайлери (швидкість), Flay/Flog (дублювання/складність).",
      "rank": "Middle",
      "category": "Testing"
    },
    {
      "id": "388",
      "title": "Які складові response’у ви тестуєте, коли пишете тест на певний ендпоінт?",
      "body": "Тестую: HTTP-статус (200, 404), тіло відповіді (JSON-структура, ключі, значення), заголовки (Content-Type), час відгуку (опціонально).",
      "rank": "Middle",
      "category": "Testing"
    },
    {
      "id": "389",
      "title": "Чи є 100% code coverage на проєкті запорукою найнижчої вірогідності щось «зламати» під час багфіксингу / імплементації нової функціональності? Поясніть свою відповідь.",
      "body": "Ні, 100% покриття не гарантує цього. Воно показує, що код протестований, але не враховує якість тестів, крайові випадки чи логічні помилки. Тести можуть бути поверхневими, тому потрібен баланс якості та покриття.",
      "rank": "Middle",
      "category": "Testing"
    },
    {
      "id": "390",
      "title": "Які загалом Continuous strategies знаєте? Чим відрізняється Continuous Deployment від Continuous Delivery?",
      "body": "Стратегії: CI (Continuous Integration) — часта інтеграція коду; CDelivery — код готовий до деплою вручну; CDeployment — автоматичний деплої після тестів. Відмінність: Delivery — ручний реліз, Deployment — автоматичний.",
      "rank": "Middle",
      "category": "DevOps"
    },
    {
      "id": "391",
      "title": "Що таке Docker? Чим відрізняється Docker від віртуальної машини?",
      "body": "Docker — платформа для контейнеризації додатків. Відмінність від VM: Docker використовує ядро хоста і контейнери (легші), VM — повну ОС із гіпервізором (важчі).",
      "rank": "Middle",
      "category": "DevOps"
    },
    {
      "id": "392",
      "title": "Для чого використовують docker-compose?",
      "body": "Docker Compose — інструмент для визначення та запуску кількох контейнерів через YAML-файл. Використовують для локальної розробки, тестування, координації сервісів (БД, API).",
      "rank": "Middle",
      "category": "DevOps"
    },
    {
      "id": "393",
      "title": "Чи вмієте працювати з Docker?",
      "body": "Так, вмію: створюю Dockerfile, запускаю контейнери (`docker run`), використовую `docker-compose` для кількох сервісів, моніторю через `docker ps`, деплою на продакшн.",
      "rank": "Middle",
      "category": "DevOps"
    },
    {
      "id": "394",
      "title": "Що таке image в Docker? Як працювати з ним у Docker?",
      "body": "Image — це шаблон із додатком і залежностями. Робота: створюю через `docker build -t name .`, переглядаю `docker images`, видаляю `docker rmi name`, пушу в реєстр `docker push`.",
      "rank": "Middle",
      "category": "DevOps"
    },
    {
      "id": "395",
      "title": "Що таке container у Docker? Як працювати з контейнерами? Як запускати та зупиняти контейнери? Як переглянути список робочих контейнерів?",
      "body": "Container — запущений екземпляр image. Робота: запускаю `docker run image`, зупиняю `docker stop container_id`, переглядаю `docker ps` (активні) або `docker ps -a` (усі).",
      "rank": "Middle",
      "category": "DevOps"
    },
    {
      "id": "396",
      "title": "Що таке Docker Daemon?",
      "body": "Docker Daemon (dockerd) — фоновий процес на хості, який керує контейнерами, image’ами, мережами та томами, обробляючи команди від клієнта.",
      "rank": "Middle",
      "category": "DevOps"
    },
    {
      "id": "397",
      "title": "Що таке Docker Client?",
      "body": "Docker Client — це CLI-інтерфейс (`docker`), через який користувач надсилає команди (run, build) до Docker Daemon для управління контейнерами.",
      "rank": "Middle",
      "category": "DevOps"
    },
    {
      "id": "398",
      "title": "Що таке Docker Hub?",
      "body": "Docker Hub — це хмарний реєстр для зберігання та поширення Docker-образів. Дозволяє завантажувати (`docker pull`) та вивантажувати (`docker push`) image’и.",
      "rank": "Middle",
      "category": "DevOps"
    },
    {
      "id": "399",
      "title": "Що таке Docker Compose?",
      "body": "Docker Compose — інструмент для запуску кількох контейнерів із конфігурацією в `docker-compose.yml`. Команди: `docker-compose up` (старт), `down` (зупинка).",
      "rank": "Middle",
      "category": "DevOps"
    },
    {
      "id": "400",
      "title": "Опишіть основні способи аутентифікації в API.",
      "body": "Способи: 1) API Key — простий ключ у запиті; 2) Basic Auth — логін/пароль у заголовку; 3) OAuth 2.0 — токени доступу (Bearer); 4) JWT — самодостатні токени з підписом; 5) Session-based — через cookies (рідше для API).",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "401",
      "title": "Назвіть основні принципи побудови REST API.",
      "body": "Принципи REST: 1) Клієнт-сервер; 2) Без стану (stateless); 3) Кешування; 4) Єдиний інтерфейс (ресурси, HTTP-методи); 5) Ієрархія ресурсів (/users/1); 6) HATEOAS (гіперпосилання, опціонально).",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "402",
      "title": "Вам потрібно спроєктувати API, які основні питання будете ставити клієнту?",
      "body": "Питання: 1) Які ресурси потрібні? 2) Які операції (CRUD)? 3) Формат даних (JSON, XML)? 4) Аутентифікація/авторизація? 5) Обмеження (rate limits)? 6) Очікуваний обсяг трафіку? 7) Специфічні вимоги (пошук, фільтрація)?",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "403",
      "title": "Які основні переваги та недоліки монолітної архітектури?",
      "body": "Переваги: простота розробки, легкий деплої, єдина база коду. Недоліки: складність масштабування, повільний реліз через залежності, ризик повного збою.",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "404",
      "title": "Які основні переваги та недоліки мікросервісної архітектури?",
      "body": "Переваги: незалежний деплої, легке масштабування, гнучкість технологій. Недоліки: складність координації, накладні витрати на мережу, проблеми з консистентністю даних.",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "405",
      "title": "Що таке SOLID? Які з принципів, на вашу думку, найчастіше порушуються, які є найбільш критичними?",
      "body": "SOLID: S — одна відповідальність; O — відкрите/закрите; L — підстановка Лісков; I — сегментація інтерфейсів; D — інверсія залежностей. Найчастіше порушують S (fat classes) і I (загальні інтерфейси). Критичні: S і D — впливають на підтримку.",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "406",
      "title": "Опишіть Singleton-патерн. Де і коли ви його використовували?",
      "body": "Singleton — один екземпляр класу (наприклад, через `@@instance`). Використовую для логерів, конфігурацій (Rails `Rails.configuration`), коли потрібен глобальний доступ.",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "407",
      "title": "Опишіть принцип роботи DNS?",
      "body": "DNS перетворює домени (example.com) в IP. Процес: 1) запит до локального резолвера; 2) звернення до root-серверів; 3) TLD-сервери (.com); 4) авторитетний сервер повертає IP.",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "408",
      "title": "Що таке code smells? Які основні ознаки поганого коду?",
      "body": "Code smells — ознаки проблем у коді. Ознаки: дублювання, довгі методи/класи, надлишкові параметри, магічні числа, тісна зв’язність, порушення SOLID.",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "409",
      "title": "Що таке reverse proxy, для чого він потрібен?",
      "body": "Reverse proxy — сервер, який приймає запити від клієнтів і перенаправляє їх на бекенд. Потрібен для балансування навантаження, кешування, безпеки (приховування серверів).",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "410",
      "title": "Що таке load balancer, основні різновиди?",
      "body": "Load balancer розподіляє трафік між серверами. Види: 1) Hardware (F5); 2) Software (Nginx, HAProxy); 3) Cloud (AWS ELB). Алгоритми: round-robin, least connections.",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "411",
      "title": "Що таке MVC та як не потрапити з ним в халепу?",
      "body": "MVC — Model (дані), View (UI), Controller (логіка). Щоб уникнути проблем: тримайте контролери легкими, виносьте бізнес-логіку в сервіси, уникайте 'fat models'.",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "412",
      "title": "Опишіть процес обробки HTTP-запиту на прикладі будь-якого вебфреймворку в Ruby (Rails, Hanami, Sinatra, Roda, etc).",
      "body": "У Rails: 1) запит до Rack; 2) маршрутизація в `routes.rb`; 3) виклик контролера; 4) взаємодія з моделлю (ActiveRecord); 5) рендеринг view або JSON; 6) відповідь клієнту.",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "413",
      "title": "Чим відрізняється refactoring від оптимізації? Як і коли потрібно виконувати кожен з вищеназваних процесів?",
      "body": "Refactoring — покращення структури коду без зміни поведінки (коли код заплутаний). Оптимізація — підвищення продуктивності (коли є bottleneck). Виконувати: рефакторинг — постійно, оптимізацію — за потреби після профілювання.",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "414",
      "title": "Чи знаєте GraphQL? Які плюси та мінуси ви бачите в порівнянні з REST?",
      "body": "Так. Плюси GraphQL: точний запит даних, один ендпоінт, гнучкість. Мінуси: складність кешування, більша нагрузка на сервер, крива навчання. REST простіший для CRUD.",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "415",
      "title": "Що таке multi-tenant architecture? Коли порекомендуєте її використовувати?",
      "body": "Multi-tenant — архітектура, де один додаток обслуговує кількох клієнтів із ізоляцією даних. Рекомендую для SaaS (наприклад, CRM), коли потрібна економія ресурсів.",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "416",
      "title": "Чим відрізняється поняття Dependency Inversion від Dependency Injection та від Inversion of Control?",
      "body": "Dependency Inversion — принцип SOLID (залежність від абстракцій). Dependency Injection — техніка передачі залежностей (через конструктор). Inversion of Control — ширший концепт передачі управління (DI — один із способів).",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "417",
      "title": "Що таке GDPR? Назвіть правила, які використовували, щоб бути GDPR compliant?",
      "body": "GDPR — регламент ЄС про захист даних. Правила: згода користувача на обробку, право на видалення (right to be forgotten), шифрування даних, логування доступу.",
      "rank": "Senior",
      "category": "General questions"
    },
    {
      "id": "418",
      "title": "Паралельне виконання коду через Thread, Fiber, Ractor. Поясніть на прикладах.",
      "body": "Thread: `t = Thread.new { sleep 1; puts 'Done' }` — багатопоточність, GIL обмежує CPU-задачі. Fiber: `f = Fiber.new { Fiber.yield 'half'; 'done' }; f.resume` — легкі потоки, керовані вручну. Ractor (Ruby 3+): `r = Ractor.new { 1 + 2 }; r.take` — справжній паралелізм, ізоляція стану.",
      "rank": "Senior",
      "category": "Metaprogramming"
    },
    {
      "id": "419",
      "title": "Дизайн-патерни: Service, Form, Value, Policy, Guard, etc. Поясніть на прикладах.",
      "body": "Service: `UserCreator.new(user_params).call` — інкапсуляція логіки. Form: `RegistrationForm.new(params)` — валідація форми. Value: `Money.new(10, 'USD')` — незмінний об’єкт. Policy: `UserPolicy.new(user).can_edit?` — правила доступу. Guard: `return unless Guard.valid?(input)` — перевірка умов.",
      "rank": "Senior",
      "category": "Metaprogramming"
    },
    {
      "id": "420",
      "title": "Розкажіть про архітектурні патерни: Monolith, Microservices, Distributed app, etc.",
      "body": "Monolith — єдиний додаток (Rails app). Microservices — незалежні сервіси (UserService, OrderService). Distributed app — система з розподіленими вузлами (Kafka + сервіси). Monolith простий, Microservices гнучкі, Distributed — для високого навантаження.",
      "rank": "Senior",
      "category": "Metaprogramming"
    },
    {
      "id": "421",
      "title": "Як організувати бізнес-логіку, коли в проєкті уже 1000+ бізнес-операцій?",
      "body": "Розділити на модулі (domains): `app/services/users`, `app/services/orders`. Використовувати Service Objects, групувати за контекстами (DDD), додати абстракції (interactors), документувати залежності.",
      "rank": "Senior",
      "category": "Metaprogramming"
    },
    {
      "id": "422",
      "title": "Що таке Sidekiq? Як правильно організовувати черги?",
      "body": "Sidekiq — бібліотека для фонових задач у Ruby (Redis). Черги: `class HardJob; include Sidekiq::Worker; sidekiq_options queue: 'high'` — пріоритетні (`high`, `default`, `low`), балансування потоків, моніторинг через UI.",
      "rank": "Senior",
      "category": "Metaprogramming"
    },
    {
      "id": "423",
      "title": "Розкажіть про оптимізацію швидкодії через benchmark, lineprof та flamegraph.",
      "body": "Benchmark: `Benchmark.measure { code }` — час виконання. Lineprof: `RubyProf.profile { code }` — аналіз рядків. Flamegraph: через `stackprof`, візуалізація вузьких місць. Приклад: знайшов повільний запит, замінив eager loading.",
      "rank": "Senior",
      "category": "Metaprogramming"
    },
    {
      "id": "424",
      "title": "Чи працювали ви з Garbage collector? Розкажіть.",
      "body": "Так, налаштовував GC у Ruby. Наприклад, `GC.start` для примусового запуску, аналіз через `GC.stat`. Оптимізація: зменшення алокацій у циклах, використання `RUBY_GC_HEAP_GROWTH_FACTOR` для великих об’єктів.",
      "rank": "Senior",
      "category": "Metaprogramming"
    },
    {
      "id": "425",
      "title": "Розкажіть про власні приклади рішень, котрими пишаєтесь і чому.",
      "body": "Реалізував кешування складних звітів у Redis із TTL, скоротивши час генерації з 10с до 0.1с. Пишаюсь, бо вирішив проблему продуктивності без зміни архітектури.",
      "rank": "Senior",
      "category": "Metaprogramming"
    },
    {
      "id": "426",
      "title": "Що таке Thread? Які особливості використання тредів у розробці?",
      "body": "Thread — потік виконання в межах процесу. Особливості в Ruby: GIL обмежує паралелізм для CPU-задач, але підходить для I/O (наприклад, `Thread.new { Net::HTTP.get('example.com') }`).",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "427",
      "title": "Що таке Process? Які особливості використання процесів у розробці?",
      "body": "Process — окремий екземпляр програми з власною пам’яттю. Особливості: через `fork` (`pid = fork { puts 'Child' }`) уникає GIL, але витратний за ресурсами, підходить для CPU-задач.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "428",
      "title": "Що таке Mutex? Наведіть приклади використання мютексів у розробці?",
      "body": "Mutex — механізм синхронізації тредів. Приклад: `mutex = Mutex.new; counter = 0; 5.times { Thread.new { mutex.synchronize { counter += 1 } } }` — уникає race conditions.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "429",
      "title": "Якщо потрібно визначити, скільки виконується той чи інший код, як порекомендуєте це зробити?",
      "body": "Використовую `Benchmark.measure { code }` для простого виміру, `RubyProf` для профілювання рядків, `StackProf` із flamegraph для детального аналізу.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "430",
      "title": "Які недоліки бачите в Ruby? Коли та як вони можуть себе проявити під час розробки?",
      "body": "Недоліки: 1) повільність (великі обчислення); 2) GIL (паралелізм); 3) слабка типізація (рефакторинг). Прояв: при високому навантаженні чи великих проєктах.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "431",
      "title": "Чи можна передати контекст виконання одного методу в інший метод? Якщо так, то як це зробити?",
      "body": "Так, через `binding`: `def a; b = 1; binding; end; b = a; eval('puts b', b)` виведе 1.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "432",
      "title": "Які callback-s знаєте в Ruby?",
      "body": "У Ruby: `method_added`, `included`, `extended`, `inherited`. У Rails: `before_save`, `after_create`, `around_destroy` тощо в ActiveRecord.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "433",
      "title": "Як реалізувати Singleton-клас у Ruby? Опишіть базові концепти.",
      "body": "`class Singleton; @@instance = new; private_class_method :new; def self.instance; @@instance; end; end` — один екземпляр через статичну змінну та обмеження створення.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "434",
      "title": "Як працює Garbage collection в Ruby? Опишіть базові концепти.",
      "body": "GC у Ruby (MRI) — mark-and-sweep: позначає живі об’єкти, видаляє недосяжні. Концепти: generational GC (Ruby 2.1+), tuning через змінні (`RUBY_GC_HEAP_GROWTH_FACTOR`).",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "435",
      "title": "Що таке Ractor? Яка різниця між класичною моделлю роботи з тредами та роботою за допомогою Ractor?",
      "body": "Ractor (Ruby 3+) — актор для паралелізму без GIL. Різниця: тредам потрібна синхронізація (Mutex), Ractor ізолює стан, передає повідомлення (`Ractor.new { Ractor.receive }`).",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "436",
      "title": "Як працюють Lazy Enumerators? Чим вони відрізняються від класичних Enumerators? Як і коли вони можуть допомогти?",
      "body": "Lazy: `[1, 2, 3].lazy.map { |x| x * 2 }.take(2)` — обчислення відкладається. Відмінність: класичні обробляють усе одразу. Допомагають: при великих даних для економії пам’яті.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "437",
      "title": "Назвіть приклади використання Fiber’ів?",
      "body": "1) Генератори: `Fiber.new { loop { Fiber.yield rand } }`; 2) Асинхронні операції: кооперативна багатозадачність у легких потоках.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "438",
      "title": "Як include додає метод модуля в клас? Що відбувається на рівні MRI? У чому різниця в порівнянні з extend та prepend?",
      "body": "`include` додає модуль у ланцюжок предків (після класу в MRI). `extend` — методи стають класовими. `prepend` — модуль перед класом у ланцюжку. MRI: змінює порядок пошуку методів.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "439",
      "title": "У вас є завдання імпортувати користувачів у базу Rails-застосунку. Користувачі записані в CSV-файлі, де кожен рядок — це дані користувача. Опишіть ваш підхід до розв’язання проблеми. Як зміниться рішення, якщо файл стане дуже великим (> 300000 рядків)?",
      "body": "Підхід: `CSV.foreach('file.csv', headers: true) { |row| User.create(row.to_h) }`. Великий файл: Sidekiq для пакетної обробки (`UserImportJob`), партиціонування CSV, `find_or_create_by` для унікальності.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "440",
      "title": "Якщо у моделі User у вас є callback, які можуть виникнути проблеми під час розв’язання попередньої задачі?",
      "body": "Проблеми: 1) повільність через `after_save`; 2) помилки валідацій; 3) тригери сторонніх дій. Рішення: `insert_all` для масового вставлення, відключення callback’ів (`skip_callback`).",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "441",
      "title": "Як ми можемо відстежувати прогрес Background Job?",
      "body": "Sidekiq: зберігати прогрес у Redis (`job.set(progress: 50)`), UI через Sidekiq::Web, кастомні метрики з проміжними оновленнями.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "442",
      "title": "Опишіть життєвий цикл Request — Response в Rails. Крізь які основні компоненти фреймворку проходить запит і для чого вони потрібні?",
      "body": "Цикл: 1) Rack (серверний інтерфейс); 2) Routes (маршрутизація); 3) Middleware (аутентифікація тощо); 4) Controller (логіка); 5) Model (дані); 6) View (рендеринг); 7) відповідь через Rack.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "443",
      "title": "Які основні типи тестів використовуєте і з якою метою?",
      "body": "Юніт (логіка), інтеграційні (взаємодія), feature (UI/поведінка), performance (швидкість). Мета: ізоляція, цілісність, користувацький досвід, оптимізація.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "444",
      "title": "Як ви ставитесь до інтеграційних тестів?",
      "body": "Позитивно: перевіряють реальну взаємодію компонентів. Але: повільніші, складніші в дебагінгу, тому балансую з юніт-тестами.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "445",
      "title": "Що таке поліморфні асоціації в ActiveRecord?",
      "body": "Поліморфні асоціації: один клас зв’язаний із кількома через тип/ключ. Приклад: `belongs_to :commentable, polymorphic: true` для Post і Photo.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "446",
      "title": "Як би ви порекомендували побудувати semantic versioning для Rails API, що працює з мобільними застосунками (IOS, Android, Web)? Верхньорівнево опишіть стратегію.",
      "body": "Стратегія: MAJOR.MINOR.PATCH (1.2.3). MAJOR — breaking changes (зміна ендпоінтів), MINOR — нові фічі, PATCH — баги. Версії в URL (/v1/), поступове виведення старих версій.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "447",
      "title": "Якщо необхідно, щоб кожен запит, що прийшов до Rails app незалежно від роуту, повертав 403 статус якнайшвидше, як би ви порекомендували реалізувати код для цієї задачі?",
      "body": "Додаю middleware: `class BlockAll; def initialize(app); @app = app; end; def call(env); [403, {}, ['Forbidden']]; end; end` у `config/application.rb`: `config.middleware.insert_before 0, BlockAll`.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "448",
      "title": "Які, на вашу думку, п’ять основних мінусів Rails? Що б ви порекомендували змінити, щоб нейтралізувати ці мінуси?",
      "body": "Мінуси: 1) продуктивність — JIT/оптимізація; 2) 'fat models' — більше Service Objects; 3) складність масштабування — мікросервіси; 4) магія — явність коду; 5) залежність від AR — альтернативи (Sequel).",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "449",
      "title": "Чи можна в Rails працювати з кількома базами, якщо так, то як це зробити?",
      "body": "Так, у Rails 6+: у `database.yml` додаю `primary` і `secondary`, у моделі `connects_to database: { writing: :secondary }`. Для репліки: `replica: true`.",
      "rank": "Senior",
      "category": "Ruby on Rails"
    },
    {
      "id": "450",
      "title": "Що таке транзакція? Які основні властивості транзакцій?",
      "body": "Транзакція — це послідовність операцій, що виконуються як єдине ціле. Властивості (ACID): Atomicity (атомарність — усе або нічого), Consistency (консистентність — правила БД), Isolation (ізоляція — незалежність), Durability (надійність — збереження після завершення).",
      "rank": "Senior",
      "category": "Databases"
    },
    {
      "id": "451",
      "title": "Що таке database lock і чим він відрізняється від транзакцій?",
      "body": "Database lock — механізм блокування даних для контролю доступу. Відмінність: транзакція — логічна одиниця роботи з ACID, lock — інструмент для ізоляції всередині транзакцій чи поза ними.",
      "rank": "Senior",
      "category": "Databases"
    },
    {
      "id": "452",
      "title": "Що таке Pessimistic та Optimistic locking?",
      "body": "Pessimistic locking — блокує дані під час транзакції (`SELECT FOR UPDATE`), передбачає конфлікти. Optimistic locking — перевіряє версію даних перед записом (через колонку `lock_version`), оптимістично припускає відсутність конфліктів.",
      "rank": "Senior",
      "category": "Databases"
    },
    {
      "id": "453",
      "title": "У нас є таблиця Users. Ми додали до неї індекс у трьох полях: first_name, last_name, email. Саме у такому порядку. Тепер робимо запит SELECT * FROM users WHERE first_name = \"Alex\" AND email = \"test@mail.com\". Чи допоможе нам індекс прискорити такий запит, і чому?",
      "body": "Частково допоможе. Індекс працює зліва направо: `first_name` використається, але `email` — ні, бо `last_name` пропущено. Для повного використання потрібен запит із усіма полями в порядку або реорганізація індексу.",
      "rank": "Senior",
      "category": "Databases"
    },
    {
      "id": "454",
      "title": "Що таке Database View? Які є види?",
      "body": "Database View — віртуальна таблиця на основі запиту. Види: звичайна (non-materialized, обчислюється щоразу), матеріалізована (materialized, зберігає дані для швидкості).",
      "rank": "Senior",
      "category": "Databases"
    },
    {
      "id": "455",
      "title": "Що таке Database trigger?",
      "body": "Trigger — автоматична процедура, що запускається при подіях у БД (INSERT, UPDATE). Наприклад, логування змін: `CREATE TRIGGER log_update AFTER UPDATE ON users ...`."
      "rank": "Senior",
      "category": "Databases"
    },
    {
      "id": "456",
      "title": "Що таке партиціювання? Опишіть кейси, коли партиціювання було б корисним?",
      "body": "Партиціювання — поділ таблиці на менші частини. Кейси: 1) архівні дані за роками; 2) логування з високим навантаженням; 3) георозподіл даних для швидкості.",
      "rank": "Senior",
      "category": "Databases"
    },
    {
      "id": "457",
      "title": "Верхньорівнево опишіть кроки для реалізації партиціювання на прикладі будь-якої СУБД.",
      "body": "У PostgreSQL: 1) створюю батьківську таблицю; 2) додаю партиції (`CREATE TABLE users_2023 PARTITION OF users ...`); 3) налаштовую тригери/правила для маршрутизації; 4) додаю індекси на партиціях.",
      "rank": "Senior",
      "category": "Databases"
    },
    {
      "id": "458",
      "title": "Що таке тригери? Як та коли їх можна використовувати? Які плюси та мінуси ви бачите порівняно з тим, щоб використовувати тригери / колбеки на рівні бекенду?",
      "body": "Тригери — автоматичні дії в БД. Використання: аудит, оновлення зв’язаних даних. Плюси: швидкість, автономність. Мінуси: складність дебагінгу, прихована логіка (vs явні колбеки в коді).",
      "rank": "Senior",
      "category": "Databases"
    },
    {
      "id": "459",
      "title": "Що таке WAL? Яку роль він відіграє?",
      "body": "WAL (Write-Ahead Logging) — журнал попереднього запису змін перед їх застосуванням. Роль: забезпечує Durability (ACID), відновлення після збоїв у PostgreSQL.",
      "rank": "Senior",
      "category": "Databases"
    },
    {
      "id": "460",
      "title": "Чи була у вас можливість / потреба використовувати шардинг? Чим відрізняється шардинг від партиціювання?",
      "body": "Так, для розподілу даних у великих проєктах. Шардинг — розподіл між серверами, партиціювання — всередині однієї БД. Шардинг складніший, але масштабується горизонтально.",
      "rank": "Senior",
      "category": "Databases"
    },
    {
      "id": "461",
      "title": "Опишіть принципи, переваги та недоліки роботи з primary / secondary (master / slave) реплікацією?",
      "body": "Принцип: master пише, slave читає. Переваги: розподіл навантаження, висока доступність. Недоліки: затримка реплікації, складність консистентності.",
      "rank": "Senior",
      "category": "Databases"
    },
    {
      "id": "462",
      "title": "Чи ознайомлені ви з CAP-теоремою? Якщо так, поясніть основну ідею.",
      "body": "Так. CAP: у розподіленій системі можна гарантувати лише 2 з 3 — Consistency, Availability, Partition tolerance. Ідея: компроміс між консистентністю та доступністю при збоях.",
      "rank": "Senior",
      "category": "Databases"
    },
    {
      "id": "463",
      "title": "Чи знаєте ACID? Як ви розумієте букву «I» в цій абревіатурі?",
      "body": "Так. ACID — принципи транзакцій. «I» (Isolation) — транзакції ізольовані, зміни однієї невидимі іншій до завершення (наприклад, через lock).",
      "rank": "Senior",
      "category": "Databases"
    },
    {
      "id": "464",
      "title": "Уявіть ситуацію, коли ваш сервер, на якому розміщений redis, з невідомих причин перезапустився. Що рекомендуєте зробити заздалегідь, щоб такі ситуації не завдали великої шкоди?",
      "body": "Рекомендації: 1) увімкнути persistence (RDB/AOF у `redis.conf`); 2) налаштувати реплікацію на secondary сервер; 3) моніторинг (DataDog); 4) регулярні бекапи.",
      "rank": "Senior",
      "category": "Databases"
    },
    {
      "id": "465",
      "title": "Чи знаєте, що таке Load Testing? Чим може допомогти розробник під час Load Testing?",
      "body": "Load Testing — тестування системи під навантаженням для оцінки продуктивності. Розробник може: оптимізувати код (кешування, запити), налаштувати індекси в БД, профілювати вузькі місця, надати метрики (NewRelic).",
      "rank": "Senior",
      "category": "Testing"
    },
    {
      "id": "466",
      "title": "Які інструменти використовують для того, щоб зібрати якнайбільше метрик під час Load Testing?",
      "body": "Інструменти: JMeter (навантаження), Gatling (скрипти Scala), Locust (Python), NewRelic/DataDog (метрики продуктивності), Prometheus+Grafana (моніторинг серверів), Rails logs (кастомні метрики).",
      "rank": "Senior",
      "category": "Testing"
    },
    {
      "id": "467",
      "title": "Які підходи ви б порекомендували використовувати, щоб пришвидшити тестування CI?",
      "body": "Підходи: 1) паралельне виконання тестів (RSpec `--split`); 2) кешування залежностей (Docker); 3) вибіркове тестування (тільки змінені файли); 4) легкі юніт-тести замість інтеграційних; 5) швидший runner (GitHub Actions).",
      "rank": "Senior",
      "category": "Testing"
    },
    {
      "id": "468",
      "title": "Як впровадити процес написання тестів, якщо на проєкті (Rails API) їх зовсім немає?",
      "body": "Кроки: 1) почати з критичних ендпоінтів (RSpec); 2) додати юніт-тести для моделей/сервісів; 3) інтеграційні тести для API (Rack::Test); 4) налаштувати CI (GitHub Actions); 5) поступово покривати legacy-код, фіксуючи баги.",
      "rank": "Senior",
      "category": "Testing"
    }
  ]
}